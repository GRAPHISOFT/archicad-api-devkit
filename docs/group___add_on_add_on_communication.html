<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Archicad C++ API" />
<meta property="og:image" content="logo.svg" />
<meta property="og:description" content="Archicad Development Kit Documentation, best practices, example codes and information hub." />
<meta property="og:url" content="https://archicadapi.graphisoft.com/documentation/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="logo.svg" />
<meta name="twitter:title" content="Archicad C++ API" />
<meta name="twitter:description" content="Archicad Development Kit Documentation, best practices, example codes and information hub." />
<!-- END twitter metadata -->
<title>Archicad 27 C++ API: Add-On - Add-On Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="https://fonts.cdnfonts.com/css/proxima-nova-2" rel="stylesheet">
<link rel="icon" href="logo.svg" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Archicad 27 C++ API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group___add_on_add_on_communication.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Add-On - Add-On Communication</div></div>
</div><!--header-->
<div class="contents">

<p>These functions provide a way for Add-Ons to communicate (pass data, call exposed commands) with one another.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_p_i___m_d_c_l_parameter.html">API_MDCLParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter structure used for inter-addon communication.  <a href="struct_a_p_i___m_d_c_l_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique identifier of an add-on.  <a href="struct_a_p_i___modul_i_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_p_i___add_on_command.html">API_AddOnCommand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the Add-On commands.  <a href="class_a_p_i___add_on_command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabf2c6f22c12d1938a84a1c7fda097671"><td class="memItemLeft" align="right" valign="top">typedef GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#gabf2c6f22c12d1938a84a1c7fda097671">APIExternalCallBackProc</a>(GSHandle params, GSErrCode returnCode)</td></tr>
<tr class="memdesc:gabf2c6f22c12d1938a84a1c7fda097671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling the responses of asynchronous external module command calls.  <br /></td></tr>
<tr class="separator:gabf2c6f22c12d1938a84a1c7fda097671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210c691daa8d5f70743d2237008daf09"><td class="memItemLeft" align="right" valign="top">typedef void __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga210c691daa8d5f70743d2237008daf09">APICommandCallBackProc</a>(GSHandle *paramsHandle, GSPtr resultData, GSErrCode returnCode)</td></tr>
<tr class="memdesc:ga210c691daa8d5f70743d2237008daf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for handling the responses of asynchronous module command calls from main event loop.  <br /></td></tr>
<tr class="separator:ga210c691daa8d5f70743d2237008daf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadc32f35161dd00f6a491c9f1a81aa70d"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#gadc32f35161dd00f6a491c9f1a81aa70d">ACAPI_AddOnAddOnCommunication_InitMDCLParameterList</a> (GSHandle *params)</td></tr>
<tr class="memdesc:gadc32f35161dd00f6a491c9f1a81aa70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a parameter list to pass to an other add-on.  <br /></td></tr>
<tr class="separator:gadc32f35161dd00f6a491c9f1a81aa70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220d6c4fccdd9133f2a3747742933145"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga220d6c4fccdd9133f2a3747742933145">ACAPI_AddOnAddOnCommunication_GetMDCLParameterNum</a> (GSHandle params, Int32 *nPars)</td></tr>
<tr class="memdesc:ga220d6c4fccdd9133f2a3747742933145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of the parameters on the parameter list.  <br /></td></tr>
<tr class="separator:ga220d6c4fccdd9133f2a3747742933145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga615d6db47f1f1a36390eb2b6477febc9"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga615d6db47f1f1a36390eb2b6477febc9">ACAPI_AddOnAddOnCommunication_AddMDCLParameter</a> (GSHandle params, <a class="el" href="struct_a_p_i___m_d_c_l_parameter.html">API_MDCLParameter</a> *mDCLParameter)</td></tr>
<tr class="memdesc:ga615d6db47f1f1a36390eb2b6477febc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a parameter to the parameter list.  <br /></td></tr>
<tr class="separator:ga615d6db47f1f1a36390eb2b6477febc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183207f69658c29cf04346b055ebacaa"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga183207f69658c29cf04346b055ebacaa">ACAPI_AddOnAddOnCommunication_GetMDCLParameter</a> (GSHandle params, <a class="el" href="struct_a_p_i___m_d_c_l_parameter.html">API_MDCLParameter</a> *mDCLParameter)</td></tr>
<tr class="memdesc:ga183207f69658c29cf04346b055ebacaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a parameter from the parameter list.  <br /></td></tr>
<tr class="separator:ga183207f69658c29cf04346b055ebacaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f80b12137f5384043a87cc2077ad8fa"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga9f80b12137f5384043a87cc2077ad8fa">ACAPI_AddOnAddOnCommunication_ChangeMDCLParameter</a> (GSHandle params, <a class="el" href="struct_a_p_i___m_d_c_l_parameter.html">API_MDCLParameter</a> *mDCLParameter)</td></tr>
<tr class="memdesc:ga9f80b12137f5384043a87cc2077ad8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a parameter on the parameter list.  <br /></td></tr>
<tr class="separator:ga9f80b12137f5384043a87cc2077ad8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ced7207eba219908657af05308a2d2"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#gac6ced7207eba219908657af05308a2d2">ACAPI_AddOnAddOnCommunication_FreeMDCLParameterList</a> (GSHandle *params)</td></tr>
<tr class="memdesc:gac6ced7207eba219908657af05308a2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the parameter list handle.  <br /></td></tr>
<tr class="separator:gac6ced7207eba219908657af05308a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d522805e88302fee1f0e7e9f801ad56"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga9d522805e88302fee1f0e7e9f801ad56">ACAPI_AddOnAddOnCommunication_RegisterSupportedService</a> (GSType cmdID, Int32 cmdVersion)</td></tr>
<tr class="memdesc:ga9d522805e88302fee1f0e7e9f801ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a command which can be used by other add-ons.  <br /></td></tr>
<tr class="separator:ga9d522805e88302fee1f0e7e9f801ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1ba42bbfc1bf673cd7bfb809f252ed"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga9c1ba42bbfc1bf673cd7bfb809f252ed">ACAPI_AddOnAddOnCommunication_InstallAddOnCommandHandler</a> (GS::Owner&lt; <a class="el" href="class_a_p_i___add_on_command.html">API_AddOnCommand</a> &gt; addOnCommand)</td></tr>
<tr class="memdesc:ga9c1ba42bbfc1bf673cd7bfb809f252ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the Add-On command handler object.  <br /></td></tr>
<tr class="separator:ga9c1ba42bbfc1bf673cd7bfb809f252ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11f17831235ccda3bfd2769a6af028b"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#gaf11f17831235ccda3bfd2769a6af028b">ACAPI_AddOnAddOnCommunication_Test</a> (const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *mdid, GSType cmdID, Int32 cmdVersion)</td></tr>
<tr class="memdesc:gaf11f17831235ccda3bfd2769a6af028b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the availability of a command.  <br /></td></tr>
<tr class="separator:gaf11f17831235ccda3bfd2769a6af028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7fdba07a0c40e317f2fe39b41e3738"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> (const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *mdid, GSType cmdID, Int32 cmdVersion, GSHandle params, GSPtr resultData, bool silentMode)</td></tr>
<tr class="memdesc:ga0e7fdba07a0c40e317f2fe39b41e3738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a command of an other add-on.  <br /></td></tr>
<tr class="separator:ga0e7fdba07a0c40e317f2fe39b41e3738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2830ca2850976881ba9536f7f95411c8"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga2830ca2850976881ba9536f7f95411c8">ACAPI_AddOnAddOnCommunication_ExternalCall</a> (const IO::Location *projectFileLoc, const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *mdid, GSType cmdID, Int32 cmdVersion, GSHandle params, bool silentMode, <a class="el" href="group___add_on_add_on_communication.html#gabf2c6f22c12d1938a84a1c7fda097671">APIExternalCallBackProc</a> *externalCallbackProc)</td></tr>
<tr class="memdesc:ga2830ca2850976881ba9536f7f95411c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a command of an other add-on in another Archicad instance.  <br /></td></tr>
<tr class="separator:ga2830ca2850976881ba9536f7f95411c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032a9bd989af442979ce7534c31c22c1"><td class="memItemLeft" align="right" valign="top">GSErrCode __ACENV_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___add_on_add_on_communication.html#ga032a9bd989af442979ce7534c31c22c1">ACAPI_AddOnAddOnCommunication_CallFromEventLoop</a> (const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *mdid, GSType cmdID, Int32 cmdVersion, GSHandle paramsHandle, bool silentMode, <a class="el" href="group___add_on_add_on_communication.html#ga210c691daa8d5f70743d2237008daf09">APICommandCallBackProc</a> *callbackProc)</td></tr>
<tr class="memdesc:ga032a9bd989af442979ce7534c31c22c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a command of an add-on from Archicad's main event loop.  <br /></td></tr>
<tr class="separator:ga032a9bd989af442979ce7534c31c22c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These functions provide a way for Add-Ons to communicate (pass data, call exposed commands) with one another. </p>
<h1><a class="anchor" id="autotoc_md75"></a>
Communication Manager</h1>
<p>The Communication Manager is a very powerful new service introduced in API v3.1.</p>
<p>In the previous versions of the API add-ons could be called by Archicad only. There were two ways to do that. The add-on could be called because of a direct user interaction, or there was a need to post a notification to it. It was not possible to call one add-on from another.</p>
<p>All of the communication manager functions begin with the <b>ACAPI_AddOnAddOnCommunication_</b> prefix. They are as follows:</p>
<blockquote class="doxtable">
<p>&zwj;<a class="el" href="group___add_on_add_on_communication.html#gaf11f17831235ccda3bfd2769a6af028b">ACAPI_AddOnAddOnCommunication_Test</a> <a class="el" href="group___add_on_add_on_communication.html#ga2830ca2850976881ba9536f7f95411c8">ACAPI_AddOnAddOnCommunication_ExternalCall</a> <a class="el" href="group___add_on_add_on_communication.html#ga032a9bd989af442979ce7534c31c22c1">ACAPI_AddOnAddOnCommunication_CallFromEventLoop</a> </p>
</blockquote>
<p>There are some functions to provide easy and controlled mechanism for parameter passing. They are:</p>
<blockquote class="doxtable">
<p>&zwj;<a class="el" href="group___add_on_add_on_communication.html#gadc32f35161dd00f6a491c9f1a81aa70d">ACAPI_AddOnAddOnCommunication_InitMDCLParameterList</a> <a class="el" href="group___add_on_add_on_communication.html#ga220d6c4fccdd9133f2a3747742933145">ACAPI_AddOnAddOnCommunication_GetMDCLParameterNum</a> <a class="el" href="group___add_on_add_on_communication.html#ga183207f69658c29cf04346b055ebacaa">ACAPI_AddOnAddOnCommunication_GetMDCLParameter</a> <a class="el" href="group___add_on_add_on_communication.html#ga615d6db47f1f1a36390eb2b6477febc9">ACAPI_AddOnAddOnCommunication_AddMDCLParameter</a> <a class="el" href="group___add_on_add_on_communication.html#ga9f80b12137f5384043a87cc2077ad8fa">ACAPI_AddOnAddOnCommunication_ChangeMDCLParameter</a> <a class="el" href="group___add_on_add_on_communication.html#gac6ced7207eba219908657af05308a2d2">ACAPI_AddOnAddOnCommunication_FreeMDCLParameterList</a> </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md76"></a>
Entry points</h1>
<p>What is an entry point of an add-on? It is a function or service which can be called from another add-on with the support of the Communication Manager.</p>
<p>The entry points are interface independent. It means that there isn't any relationship between the commands put into the Archicad menu structure and the entry points. The first set is controlled by the <a class="el" href="group___menu_item.html#gaf036aca311d48c1bf57467835af679e3">ACAPI_MenuItem_RegisterMenu</a> or <a class="el" href="group___add_on_integration.html#ga8959750694f90747a9ddc44cbaad5bef">ACAPI_AddOnIntegration_RegisterFileType</a> and the like, the second type entry points are given by <a class="el" href="group___add_on_add_on_communication.html#ga9d522805e88302fee1f0e7e9f801ad56">ACAPI_AddOnAddOnCommunication_RegisterSupportedService</a>.</p>
<h1><a class="anchor" id="autotoc_md77"></a>
Registration</h1>
<p>An add-on can have as many entry points as it wants, and each of them has to be registered in the <a class="el" href="group___add_on_lifetime.html#gab757c521739c9953ea4836b8f2076d1e">RegisterInterface</a> function of your add-on with <a class="el" href="group___add_on_add_on_communication.html#ga9d522805e88302fee1f0e7e9f801ad56">ACAPI_AddOnAddOnCommunication_RegisterSupportedService</a>. This function tells Archicad that the add-on can be called by another. The parameters of this function are the following:</p>
<ul>
<li>the identifier of the entry point,</li>
<li>the version of the entry point,</li>
</ul>
<p>Refer to the function description for more details.</p>
<p>Later in the Initialize function the add-on has to register callback function to handle the different supported commands. The <a class="el" href="group___add_on_integration.html#gad411b8a639aed4e3598827b0a4eea81e">ACAPI_AddOnIntegration_InstallModulCommandHandler</a> function's parameters identify the command (with its ID and version number), and the last parameter supplies the module command handler callback function. This callback function then receives the parameters, may optionally pass back its results in a separate pointer, and is also informed whether it should run in silent mode.</p>
<h1><a class="anchor" id="autotoc_md78"></a>
Entry point identification</h1>
<p>An entry point is identified by the following two components:</p>
<ul>
<li>an add-on identifier. For this purposes the API uses the <a class="el" href="md__common_doxygen_files_2_articles_2_required___resources.html#RequiredResources">'MDID'</a> resource. Simply put the ID of the target add-on into an <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> structure to identify it.</li>
<li>an entry point identifier. This should be the same what the target add-on used as the first parameter of the <a class="el" href="group___add_on_add_on_communication.html#ga9d522805e88302fee1f0e7e9f801ad56">ACAPI_AddOnAddOnCommunication_RegisterSupportedService</a>.</li>
<li>the version of the entry point.</li>
</ul>
<p>This means that entry point IDs must be unique in the world of an add-on. Different add-ons may have the same entry point IDs, but locally an add-on is not allowed to specify the same ID more than once.</p>
<p>On the caller add-ons side, it may check for the existence of the necessary entry points of the target add-on in its own <a class="el" href="group___add_on_lifetime.html#gab757c521739c9953ea4836b8f2076d1e">RegisterInterface</a> function, with <a class="el" href="group___add_on_integration.html#ga7f451cfcaeed7fd9a2fad87900ad500b">ACAPI_AddOnIntegration_RegisterRequiredService</a>.</p>
<h1><a class="anchor" id="autotoc_md79"></a>
Version control</h1>
<p>The last issue is version control. The caller add-on must specify the required version of the entry point also. The API assumes backward compatibility. When an add-on tests for an entry point's availability, the following cases may occur (assuming the identification was successful):</p>
<ul>
<li>the entry point version is less than the requested one. In this case an error is returned.</li>
<li>the entry point version is greater or equal with the requested one. The API returns successfully, as it assumes backward compatibility.</li>
</ul>
<p>When you assign a version number to an entry point, you must adhere to the following rules:</p>
<ul>
<li>when backward compatibility can be assured, simply increase the version number.</li>
<li>when the compatibility cannot be assured, change the entry point identifier.</li>
</ul>
<p>Note that the most general cases where the compatibility issues are important are:</p>
<ul>
<li>there are changes in the interface (the parameters, which the caller can pass, have to be modified)</li>
<li>there are changes in the algorithm (the output will differ on the same parameters passed)</li>
</ul>
<p>In either cases keep the compatibility, if possible. Upon a call of an entry point, the Communication Manager first identifies the command. Ifit is available, it checks the entry point version. If there isn't any version problem, it calls the entry point by passing the required version number. Use this data to ensure the same environment and behavior.</p>
<h1><a class="anchor" id="autotoc_md80"></a>
Control of execution</h1>
<p>It is very important to understand what happens in the background when the API calls an add-on.</p>
<p>In general the API allocates a unique environment to each executed add-on. Normally only one add-on is executed by the API, only one add-on is in one of its callback functions. However there are cases when there are more add-ons in the call stack.</p>
<ul>
<li>when there is a need to post a notification to certain add-ons.</li>
<li>the add-on has the right to call another add-on's functionality.</li>
</ul>
<p>In these cases more add-ons are executed at the same time, they are all in their notification or module command handlerfunctions.</p>
<p>Note, that <b>this is not a real multiprocessing architecture</b>.</p>
<p>The API maintains a call stack all the time, and only the top-most add-on has the right to call the API services. This is the add-on whose environment is the active one. Once the top-most add-on has returned from its callback function, the API takes the next add-on on the stack, and makes its environment to be the active one.</p>
<p>So, the structure is nested, instead of being parallel.</p>
<p>The figure below tries to explain the system. The user has called a command which is implemented in the add-on <b>A</b>. add-on <b>A</b> calls a function of add-on <b>B</b>. It performs an operation which results to post a notification to add-on <b>C</b>.</p>
<div class="image">
<img src="ClientStack.png" alt=""/>
</div>
<p><em>Figure #1: the API call stack and client environments</em></p>
<p>The vertical lines show which environment is the active one. On the right side the call stack maintained by the API is shown.</p>
<p>On Figure #2 you can see how the <b>CommunicationManager</b> and <b>CommunicationClient</b> example projects communicate to each other.</p>
<div class="image">
<img src="ClientCall.png" alt=""/>
</div>
<p><em>Figure #2: communication architectures</em></p>
<p>On the left side of the picture the normal situation is shown.</p>
<p>Client <b>A</b> (which is the CommunicationManager example project) wants to call the entry point <code>CMD1</code> (command 1) of client <b>B</b> (the CommunicationClient example project). It calls the <a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> function with the necessary IDs. The API loads the add-on <b>B</b>, and calls its module command handler function, registered for the <code>CMD1</code> command. When <b>B</b> has returned, the control goes back to the API, into the <a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> function. It switches the environment back to the one owned by <b>A</b>, and returns. Client <b>A</b> gets the control and can continue working.</p>
<p>This system is quite simple, however sometimes it is not strong enough. The <a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> function is a very robust one, with a lot of overhead. First, it has to decide whether the addressed add-on is installed. Then it has to be loaded into the memory and initialized; of course just if it is was not loaded before. The caller add-on may want to pass some parameters too, the method to do that also has a strong overhead (the details are explained later in this paper).</p>
<p>On the right side of the picture a more complex architecture is shown, where the two add-ons can call each other directly. For this purpose client <b>B</b> has implemented two special entry points:</p>
<p><code>BEGB</code> is to setup a binary link. Actually it just fills up a function table, or returns a pointer to a class with virtual functions initialized. The most important, that it calls the <a class="el" href="group___add_on_lifetime.html#ga5d158f85a2e2940dd689c4cd1c622199">ACAPI_KeepInMemory</a> function to forcethe API to keep it in the memory. When the ACAPI_AddOnAddOnCommunication_Call function returns to client <b>A</b>, he gets the necessary function pointers, and as client <b>B</b> is in the memory, they are valid, they can be called. From this point, client <b>A</b> is also allowed to pass function pointers to client <b>B.</b> So, an environment is set up where two add-ons can call each other directly, with the standard C/C++ calls, without the assistance of the</p>
<p><b>Communication Manager</b>.</p>
<p><code>ENDB</code> is just to dispose the binary link. Actually the only task it has to do is to call the <a class="el" href="group___add_on_lifetime.html#ga5d158f85a2e2940dd689c4cd1c622199">ACAPI_KeepInMemory</a> function to sign that it can be unloaded.</p>
<p>What is <b>very important to know is</b>, that in this architecture client <b>B</b> is running under the API environment of client <b>A</b>. He can call any of the API services, but the API handles client <b>A</b> as the active one. The API will process these request in a way, as they would be called by client <b>A</b>. This critical session is shown by a zigzag type line on the picture.</p>
<p>Please note that from Archicad 10 it is a possible to make an add-on command execute in an external Archicad instance to perform operation on a different project file. For more details refer to the <a class="el" href="group___add_on_add_on_communication.html#ga2830ca2850976881ba9536f7f95411c8">ACAPI_AddOnAddOnCommunication_ExternalCall</a> function.</p>
<p>Please note that from Archicad 19 you can execute add-on command forced from main event loop using <a class="el" href="group___add_on_add_on_communication.html#ga032a9bd989af442979ce7534c31c22c1">ACAPI_AddOnAddOnCommunication_CallFromEventLoop</a> function.</p>
<h1><a class="anchor" id="autotoc_md81"></a>
Parameter passing</h1>
<p>Parameters should be passed in the <code>params</code> argument to the <a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> function. This handle -whose internal format is not public- is owned by the API. The content is not checkedby the API, it just simply passed to the called entry point.</p>
<p>The parameters should be listed in the public header file of the add-on. Each parameter is identified by its name. Each parameter has a value type, which can be either a string, integer or float type. The API does not check the passed parameters, it merely passes those onto the called add-on. Consistency must be validated by the called add-on's entry function.</p>
<p>The workflow is:</p>
<ul>
<li>the caller add-on must initialize a parameter list with the <a class="el" href="group___add_on_add_on_communication.html#gadc32f35161dd00f6a491c9f1a81aa70d">ACAPI_AddOnAddOnCommunication_InitMDCLParameterList</a> function,</li>
<li>the required parameters can be appended to this list with the <a class="el" href="group___add_on_add_on_communication.html#ga615d6db47f1f1a36390eb2b6477febc9">ACAPI_AddOnAddOnCommunication_AddMDCLParameter</a> function,</li>
<li>the called add-on can explode the passed parameters with the <a class="el" href="group___add_on_add_on_communication.html#ga220d6c4fccdd9133f2a3747742933145">ACAPI_AddOnAddOnCommunication_GetMDCLParameterNum</a> and <a class="el" href="group___add_on_add_on_communication.html#ga183207f69658c29cf04346b055ebacaa">ACAPI_AddOnAddOnCommunication_GetMDCLParameter</a> functions,</li>
<li>parameters may be modified with the <a class="el" href="group___add_on_add_on_communication.html#ga9f80b12137f5384043a87cc2077ad8fa">ACAPI_AddOnAddOnCommunication_ChangeMDCLParameter</a> function.</li>
<li>the parameter list must be disposed by the caller with the help of <a class="el" href="group___add_on_add_on_communication.html#gac6ced7207eba219908657af05308a2d2">ACAPI_AddOnAddOnCommunication_FreeMDCLParameterList</a> function.</li>
</ul>
<p>It is very <b>important</b>, that the parameters must be relative to the <b>factory default</b> parameters of the called add-on. The called add-on first must set up its factory default parameters, then while retrieving the passed parameters one by one, the defaults should be modified. If no parameters were passed (<code>params == nullptr</code>) the factory default parameters should be used without any modification. Another important note is that the parameters must be <b>interpreted in the same order</b> as they have been passed.</p>
<p><b>The above rules ensure that the execution of the entry points will not be context sensitive.</b> No matter what the current defaults are (saved into the preferences), parameters are interpreted based on the factory defaults. It doesn't matter that some parameters are not passed to the client, as they have defaults.</p>
<p>Let's take an example.</p>
<p>The DXF/DWG add-on exports an entry point the open an AutoCAD drawing. Its options dialog also has a Default button to set and use the factory default parameters. The add-on emulates the behavior of this dialog while interpreting the passed parameters.</p>
<h1><a class="anchor" id="autotoc_md82"></a>
Interface control</h1>
<p>The caller add-on can disable all interface elements of the called add-on with the <code>silentMode</code> parameter.</p>
<p>If this parameter is set to <code>true</code>, the called add-on is not allowed to open its dialogs and alerts. In the case it is <code>false</code> the option dialog must appear; of course after processing the passed parameters. The user is allowed to modify any parameter. In the case the modifications may have an effect on the passed parameters, use the ACAPI_AddOnAddOnCommunication_ChangeMDCLParameter function to allow the caller add-on to track the changes.</p>
<h1><a class="anchor" id="autotoc_md83"></a>
Return values</h1>
<p>There are two ways to return parameters to the caller.</p>
<p>The default option is to use the return value of the <a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> call. The value returned by this function is the value returned by the client's module command handler function.</p>
<p>The other way is to use the <code>resultData</code> parameter. This is a simple pointer, which can be used for any purpose. The specification must be given by the called add-on.</p>
<h1><a class="anchor" id="autotoc_md84"></a>
Documentation</h1>
<p>It is absolutely necessary to provide developer documentation for each add-on which publishes its interface. This document should give details what the functionality of the entry point is, what parameters can be passed, how they are interpreted and what return vales are provided.</p>
<p>By default put this document into the same folder where your add-on is installed. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga210c691daa8d5f70743d2237008daf09" name="ga210c691daa8d5f70743d2237008daf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga210c691daa8d5f70743d2237008daf09">&#9670;&#160;</a></span>APICommandCallBackProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void __ACENV_CALL APICommandCallBackProc(GSHandle *paramsHandle, GSPtr resultData, GSErrCode returnCode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling the responses of asynchronous module command calls from main event loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramsHandle</td><td>[in/out] pointer to the passed parameters for the module command </td></tr>
    <tr><td class="paramname">resultData</td><td>[in] optional result data from the <a class="el" href="group___add_on_integration.html#ga51a353b9945c01563763bd4a9403b956">APIModulCommandProc</a> function of the server side add-on </td></tr>
    <tr><td class="paramname">returnCode</td><td>[in] the return value of the <a class="el" href="group___add_on_integration.html#ga51a353b9945c01563763bd4a9403b956">APIModulCommandProc</a> function of the server side add-on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is the handler function to be used for collecting the results of module command calls in asynchronous case. For more details refer to the description of the <a class="el" href="group___add_on_add_on_communication.html#ga032a9bd989af442979ce7534c31c22c1">ACAPI_AddOnAddOnCommunication_CallFromEventLoop</a> function. </dd></dl>

</div>
</div>
<a id="gabf2c6f22c12d1938a84a1c7fda097671" name="gabf2c6f22c12d1938a84a1c7fda097671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf2c6f22c12d1938a84a1c7fda097671">&#9670;&#160;</a></span>APIExternalCallBackProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef GSErrCode __ACENV_CALL APIExternalCallBackProc(GSHandle params, GSErrCode returnCode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for handling the responses of asynchronous external module command calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[in/out] the passed parameters for the module command </td></tr>
    <tr><td class="paramname">returnCode</td><td>[in] the return value of the APIModulCommandProc function of the server side add-on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is the handler function to be used for collecting the results of external module command calls in asynchronous case. For more details refer to the description of the <a class="el" href="group___add_on_add_on_communication.html#ga2830ca2850976881ba9536f7f95411c8">ACAPI_AddOnAddOnCommunication_ExternalCall</a> function. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga615d6db47f1f1a36390eb2b6477febc9" name="ga615d6db47f1f1a36390eb2b6477febc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga615d6db47f1f1a36390eb2b6477febc9">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_AddMDCLParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_AddMDCLParameter </td>
          <td>(</td>
          <td class="paramtype">GSHandle&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___m_d_c_l_parameter.html">API_MDCLParameter</a> *&#160;</td>
          <td class="paramname"><em>mDCLParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a parameter to the parameter list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[in/out] Handle of the parameter list </td></tr>
    <tr><td class="paramname">mDCLParameter</td><td>[in] Pointer to the parameter to be appended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - params, par or par-&gt;name is nullptr, </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to append a parameter to the parameter list used in inter-addon communications. For the utilization details of <a class="el" href="group___add_on_add_on_communication.html#ga615d6db47f1f1a36390eb2b6477febc9">ACAPI_AddOnAddOnCommunication_AddMDCLParameter</a> refer to the Parameter Passing section of the Communication Manager. </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">See the Communication_Manager</div>
<div class="line">example.</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga0e7fdba07a0c40e317f2fe39b41e3738" name="ga0e7fdba07a0c40e317f2fe39b41e3738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e7fdba07a0c40e317f2fe39b41e3738">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_Call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_Call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *&#160;</td>
          <td class="paramname"><em>mdid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSType&#160;</td>
          <td class="paramname"><em>cmdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>cmdVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSHandle&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSPtr&#160;</td>
          <td class="paramname"><em>resultData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silentMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a command of an other add-on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdid</td><td>[in] the identifier of the target add-on. It is defined by the 'MDID' resource. </td></tr>
    <tr><td class="paramname">cmdID</td><td>[in] the identifier of the command to be executed. </td></tr>
    <tr><td class="paramname">cmdVersion</td><td>[in] the required command version </td></tr>
    <tr><td class="paramname">params</td><td>[in/out] passed parameters (optional). See the Inter-add-on communication section of the <code>ACAPI_Goodies</code> functions </td></tr>
    <tr><td class="paramname">resultData</td><td>[out] results returned by the command (optional) </td></tr>
    <tr><td class="paramname">silentMode</td><td>[in] instruct the target add-on to work in silent mode. No option dialogs, error alerts...etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - the function completed successfully</li>
<li>APIERR_BADPARS - the mdid parameter is nullptr</li>
<li>APIERR_MODULNOTINSTALLED - the referenced add-on is not installed</li>
<li>APIERR_MODULCMDNOTSUPPORTED - the referenced command is not supported by the target add-on</li>
<li>APIERR_MODULCMDVERSNOTSUPPORTED - the requested command version is too new; not supported by the target add-on </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to call a command implemented in an other add-on. Refer to the <a class="el" href="group___add_on_add_on_communication.html#gaf11f17831235ccda3bfd2769a6af028b">ACAPI_AddOnAddOnCommunication_Test</a> function to test the command availability. Refer to the Communication Manager for more detailed description on<ul>
<li>how to pass parameters,</li>
<li>how to get return values,</li>
<li>how the heaps and API environments are managed by the API. From Archicad 10 you can execute add-on command with <a class="el" href="group___add_on_add_on_communication.html#ga2830ca2850976881ba9536f7f95411c8">ACAPI_AddOnAddOnCommunication_ExternalCall</a> on a different plan loaded into another instance of Archicad. From Archicad 19 you can execute add-on command forced from main event loop with <a class="el" href="group___add_on_add_on_communication.html#ga032a9bd989af442979ce7534c31c22c1">ACAPI_AddOnAddOnCommunication_CallFromEventLoop</a> function. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">The following sample retrieves the location of the <span class="keywordflow">default</span> translator currently set <span class="keywordflow">for</span> the DXF/DWG add-on (provided that the add-on is currently loaded):</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga032a9bd989af442979ce7534c31c22c1" name="ga032a9bd989af442979ce7534c31c22c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032a9bd989af442979ce7534c31c22c1">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_CallFromEventLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_CallFromEventLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *&#160;</td>
          <td class="paramname"><em>mdid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSType&#160;</td>
          <td class="paramname"><em>cmdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>cmdVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSHandle&#160;</td>
          <td class="paramname"><em>paramsHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silentMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___add_on_add_on_communication.html#ga210c691daa8d5f70743d2237008daf09">APICommandCallBackProc</a> *&#160;</td>
          <td class="paramname"><em>callbackProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a command of an add-on from Archicad's main event loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdid</td><td>[in] the identifier of the target add-on. It is defined by the 'MDID' resource </td></tr>
    <tr><td class="paramname">cmdID</td><td>[in] the identifier of the command to be executed </td></tr>
    <tr><td class="paramname">cmdVersion</td><td>[in] the required command version </td></tr>
    <tr><td class="paramname">paramsHandle</td><td>[in/out] passed parameters (optional). See the Inter-add-on communication section of the <code>ACAPI_Goodies</code> functions </td></tr>
    <tr><td class="paramname">silentMode</td><td>[in] instruct the target add-on to work in silent mode. No option dialogs, error alerts...etc. </td></tr>
    <tr><td class="paramname">callbackProc</td><td>[in] optional callback procedure for handling the responses asynchronously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - the function completed successfully</li>
<li>APIERR_BADPARS - the mdid parameter is nullptr</li>
<li>APIERR_MODULNOTINSTALLED - the referenced add-on is not installed</li>
<li>APIERR_MODULCMDNOTSUPPORTED - the referenced command is not supported by the target add-on</li>
<li>APIERR_MODULCMDVERSNOTSUPPORTED - the requested command version is too new; not supported by the target add-on </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to call a command implemented in an add-on from Archicad's main event loop. Refer to the <a class="el" href="group___add_on_add_on_communication.html#gaf11f17831235ccda3bfd2769a6af028b">ACAPI_AddOnAddOnCommunication_Test</a> function to test the command availability. Refer to the Communication Manager for more detailed description on<ul>
<li>how to pass parameters,</li>
<li>how to get return values,</li>
<li>how the heaps and API environments are managed by the API. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">The following sample starts a <span class="keyword">new</span> working thread and calls an add-on command to place a column in the given position:</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga9f80b12137f5384043a87cc2077ad8fa" name="ga9f80b12137f5384043a87cc2077ad8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f80b12137f5384043a87cc2077ad8fa">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_ChangeMDCLParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_ChangeMDCLParameter </td>
          <td>(</td>
          <td class="paramtype">GSHandle&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___m_d_c_l_parameter.html">API_MDCLParameter</a> *&#160;</td>
          <td class="paramname"><em>mDCLParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies a parameter on the parameter list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[in/out] Handle of the parameter list </td></tr>
    <tr><td class="paramname">mDCLParameter</td><td>[in] Pointer to the modified parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - params or par is nullptr, </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to modify a parameter on the parameter list handle used in inter-addon communications. For the utilization details of <a class="el" href="group___add_on_add_on_communication.html#ga9f80b12137f5384043a87cc2077ad8fa">ACAPI_AddOnAddOnCommunication_ChangeMDCLParameter</a> refer to the Parameter Passing section of the Communication Manager. </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">See the Communication_Client</div>
<div class="line">example.</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga2830ca2850976881ba9536f7f95411c8" name="ga2830ca2850976881ba9536f7f95411c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2830ca2850976881ba9536f7f95411c8">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_ExternalCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_ExternalCall </td>
          <td>(</td>
          <td class="paramtype">const IO::Location *&#160;</td>
          <td class="paramname"><em>projectFileLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *&#160;</td>
          <td class="paramname"><em>mdid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSType&#160;</td>
          <td class="paramname"><em>cmdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>cmdVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSHandle&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silentMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___add_on_add_on_communication.html#gabf2c6f22c12d1938a84a1c7fda097671">APIExternalCallBackProc</a> *&#160;</td>
          <td class="paramname"><em>externalCallbackProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a command of an other add-on in another Archicad instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projectFileLoc</td><td>[in] the location of the project file to be opened during the remote call </td></tr>
    <tr><td class="paramname">mdid</td><td>[in] the identifier of the target add-on. It is defined by the 'MDID' resource </td></tr>
    <tr><td class="paramname">cmdID</td><td>[in] the identifier of the command to be executed </td></tr>
    <tr><td class="paramname">cmdVersion</td><td>[in] the required command version </td></tr>
    <tr><td class="paramname">params</td><td>[in/out] passed parameters (optional). See the Inter-add-on communication section of the <code>ACAPI_Goodies</code> functions </td></tr>
    <tr><td class="paramname">silentMode</td><td>[in] instruct the target add-on to work in silent mode. No option dialogs, error alerts...etc. </td></tr>
    <tr><td class="paramname">externalCallbackProc</td><td>[in] optional callback procedure for handling the responses asynchronously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - the function completed successfully</li>
<li>APIERR_BADPARS - the mdid or the projectFileLoc parameter is nullptr</li>
<li>APIERR_REFUSEDPAR - the location defined by projectFileLoc is empty or invalid</li>
<li>APIERR_MODULNOTINSTALLED - the referenced add-on is not installed</li>
<li>APIERR_MODULCMDNOTSUPPORTED - the referenced command is not supported by the target add-on</li>
<li>APIERR_MODULCMDVERSNOTSUPPORTED - the requested command version is too new; not supported by the target add-on</li>
<li>APIERR_CANCEL - the external operation has been canceled (either by the user or due to communication problem) </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to call an add-on implemented command on a different plan loaded into another instance of Archicad. The system provides that the requested project would be available for performing the command in the following way:<ul>
<li>if there is already an Archicad application running with the specified plan, it attempts to reserve it for the external call (it waits for the application to be available if currently busy with some other operation)</li>
<li>if there is an Archicad running with currently no plan opened in it (empty), it reserves that application and makes it load the project file</li>
<li>if there is no available Archicad running, it launches a new application instance with loading the requested project file After the external Archicad instance is reserved for serving the add-on command call, the operation works similarly to the <a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> function. On the server side the callee add-on does not even realize that the command request comes from another application instance. The only difference is that the resultData parameter is always nullptr when calling its APIModulCommandProc handler, because this pointer cannot be passed between ARCHICADs. However you can change the content of the params handle modifying any parameters to communicate the result to the caller. The caller can decide the function to return immediately after sending the command request (asynchronous operation) or to wait for the external call to be finished (synchronous operation). You need to pass an APIExternalCallBackProc handler function to collect the responses asynchronously; if this parameter is nullptr, the function does not return until the external operation is finished. The advantage of the asynchronous way is that you can initiate more calls even with different project files at the same time, and the internal task scheduler will optimize the sequence of execution. Please note that if you use a loop for waiting for the asynchronous responses, do not reserve the processor time superfluously, let other threads run by calling the TIWait function of the GSRoot module. Refer to the Communication Manager for more detailed description on</li>
<li>how to pass parameters</li>
<li>how to get return values</li>
<li>how the heaps and API environments are managed by the API </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">The following sample exports the elements of the example project into a specified DWG file by calling the standard DXF/DWG add-on synchronously in an external Archicad:</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gac6ced7207eba219908657af05308a2d2" name="gac6ced7207eba219908657af05308a2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ced7207eba219908657af05308a2d2">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_FreeMDCLParameterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_FreeMDCLParameterList </td>
          <td>(</td>
          <td class="paramtype">GSHandle *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the parameter list handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[in] Handle of the parameter list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - params is nullptr </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to dispose a parameter list handle used in inter-addon communications. For the utilization details of <a class="el" href="group___add_on_add_on_communication.html#gac6ced7207eba219908657af05308a2d2">ACAPI_AddOnAddOnCommunication_FreeMDCLParameterList</a> refer to the Parameter Passing section of the Communication Manager. </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">See the Communication_Manager</div>
<div class="line">example.</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga183207f69658c29cf04346b055ebacaa" name="ga183207f69658c29cf04346b055ebacaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga183207f69658c29cf04346b055ebacaa">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_GetMDCLParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_GetMDCLParameter </td>
          <td>(</td>
          <td class="paramtype">GSHandle&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___m_d_c_l_parameter.html">API_MDCLParameter</a> *&#160;</td>
          <td class="paramname"><em>mDCLParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a parameter from the parameter list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[in] The handle of the parameter list </td></tr>
    <tr><td class="paramname">mDCLParameter</td><td>[out] Pointer to the requested parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - params or par is nullptr</li>
<li>APIERR_BADNAME - The passed parameter name is not found on the parameter list</li>
<li>APIERR_BADINDEX - The passed parameter index is out of range (checked only if </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga220d6c4fccdd9133f2a3747742933145" name="ga220d6c4fccdd9133f2a3747742933145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220d6c4fccdd9133f2a3747742933145">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_GetMDCLParameterNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_GetMDCLParameterNum </td>
          <td>(</td>
          <td class="paramtype">GSHandle&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32 *&#160;</td>
          <td class="paramname"><em>nPars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of the parameters on the parameter list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[in] The handle of the parameter list </td></tr>
    <tr><td class="paramname">nPars</td><td>[out] Number of the parameters on the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - params is nullptr </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to retrieve the number of the parameters on the parameter list handle used in inter-addon communications. For the utilization details of <a class="el" href="group___add_on_add_on_communication.html#ga220d6c4fccdd9133f2a3747742933145">ACAPI_AddOnAddOnCommunication_GetMDCLParameterNum</a> refer to the Parameter Passing section of the Communication Manager. </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">See the Communication_Client</div>
<div class="line">example.</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gadc32f35161dd00f6a491c9f1a81aa70d" name="gadc32f35161dd00f6a491c9f1a81aa70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc32f35161dd00f6a491c9f1a81aa70d">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_InitMDCLParameterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_InitMDCLParameterList </td>
          <td>(</td>
          <td class="paramtype">GSHandle *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a parameter list to pass to an other add-on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>[out] The address of a handle to be initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - params is nullptr</li>
<li>APIERR_MEMFULL - low memory condition </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to initialize a parameter list handle used in inter-addon communications. For the utilization details of <a class="el" href="group___add_on_add_on_communication.html#gadc32f35161dd00f6a491c9f1a81aa70d">ACAPI_AddOnAddOnCommunication_InitMDCLParameterList</a> refer to the Parameter Passing section of the Communication Manager. </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">See the Communication_Manager</div>
<div class="line">example.</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga9c1ba42bbfc1bf673cd7bfb809f252ed" name="ga9c1ba42bbfc1bf673cd7bfb809f252ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c1ba42bbfc1bf673cd7bfb809f252ed">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_InstallAddOnCommandHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_InstallAddOnCommandHandler </td>
          <td>(</td>
          <td class="paramtype">GS::Owner&lt; <a class="el" href="class_a_p_i___add_on_command.html">API_AddOnCommand</a> &gt;&#160;</td>
          <td class="paramname"><em>addOnCommand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs the Add-On command handler object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addOnCommand</td><td>[in] The Add-On command handler object. After the <code>ACAPI_AddOnAddOnCommunication_InstallAddOnCommandHandler</code> is called, the ownership is passed and the object can not be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>APIERR_REFUSEDPAR - The addOnCommand parameter is nullptr.</li>
<li>APIERR_BADNAME - There is already an <a class="el" href="class_a_p_i___add_on_command.html">API_AddOnCommand</a> installed with the same name for this Add-On.</li>
<li>APIERR_BADPARS - The input, output or schema definitions is not in a valid JSON format.</li>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function installs a handler object for the corresponding HTTP requests. The handler object is identified by the Add-On MDID and its name. The <code>ACAPI_AddOnAddOnCommunication_InstallAddOnCommandHandler</code> function should be called from Initialize. After a successful <code>ACAPI_AddOnAddOnCommunication_InstallAddOnCommandHandler</code> function call, the Add-On stays in the memory. </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">Refer to the AddOnCommand_Test</div>
<div class="line"> </div>
<div class="line">example project of the API Development Kit.</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga9d522805e88302fee1f0e7e9f801ad56" name="ga9d522805e88302fee1f0e7e9f801ad56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d522805e88302fee1f0e7e9f801ad56">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_RegisterSupportedService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_RegisterSupportedService </td>
          <td>(</td>
          <td class="paramtype">GSType&#160;</td>
          <td class="paramname"><em>cmdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>cmdVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a command which can be used by other add-ons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdID</td><td>[in] The command identifier of the supported service. </td></tr>
    <tr><td class="paramname">cmdVersion</td><td>[in] The command version of the supported service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function registers one of your add-on's command, and makes it avaliable for other add-ons. This should be called from the RegisterInterface function of the add-on. </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="comment">//------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Interface definitions</span></div>
<div class="line"><span class="comment">//------------------------------------------------------</span></div>
<div class="line">GSErrCode __ACENV_CALL  <a class="code hl_function" href="group___add_on_lifetime.html#gab757c521739c9953ea4836b8f2076d1e">RegisterInterface</a> (<span class="keywordtype">void</span>)</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    GSErrCode   err;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Register command services</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    err = <a class="code hl_function" href="group___add_on_add_on_communication.html#ga9d522805e88302fee1f0e7e9f801ad56">ACAPI_AddOnAddOnCommunication_RegisterSupportedService</a> (<span class="stringliteral">&#39;DWFO&#39;</span>, 4L);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> err;</div>
<div class="line">}               <span class="comment">// RegisterInterface</span></div>
<div class="ttc" id="agroup___add_on_add_on_communication_html_ga9d522805e88302fee1f0e7e9f801ad56"><div class="ttname"><a href="group___add_on_add_on_communication.html#ga9d522805e88302fee1f0e7e9f801ad56">ACAPI_AddOnAddOnCommunication_RegisterSupportedService</a></div><div class="ttdeci">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_RegisterSupportedService(GSType cmdID, Int32 cmdVersion)</div><div class="ttdoc">Registers a command which can be used by other add-ons.</div></div>
<div class="ttc" id="agroup___add_on_lifetime_html_gab757c521739c9953ea4836b8f2076d1e"><div class="ttname"><a href="group___add_on_lifetime.html#gab757c521739c9953ea4836b8f2076d1e">RegisterInterface</a></div><div class="ttdeci">GSErrCode __ACDLL_CALL RegisterInterface(void)</div><div class="ttdoc">In this function the add-on can register its services, and menu commands.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaf11f17831235ccda3bfd2769a6af028b" name="gaf11f17831235ccda3bfd2769a6af028b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf11f17831235ccda3bfd2769a6af028b">&#9670;&#160;</a></span>ACAPI_AddOnAddOnCommunication_Test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode __ACENV_CALL ACAPI_AddOnAddOnCommunication_Test </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___modul_i_d.html">API_ModulID</a> *&#160;</td>
          <td class="paramname"><em>mdid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSType&#160;</td>
          <td class="paramname"><em>cmdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>cmdVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the availability of a command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdid</td><td>[in] the identifier of the target add-on. It is defined by the 'MDID' resource. </td></tr>
    <tr><td class="paramname">cmdID</td><td>[in] the identifier of the command to be tested. </td></tr>
    <tr><td class="paramname">cmdVersion</td><td>[in] the required command version </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - the command is installed, it may be called</li>
<li>APIERR_BADPARS - the mdid parameter is nullptr</li>
<li>APIERR_MODULNOTINSTALLED - the referenced add-on is not installed</li>
<li>APIERR_MODULCMDNOTSUPPORTED - the referenced command is not supported by the target add-on</li>
<li>APIERR_MODULCMDVERSNOTSUPPORTED - the requested command version is too new; not supported by the target add-on </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to check the availability of an add-on's command. Call this function to check whether the requested command of another add-on is available. Depending on the result, for example you can modify your add-on's interface. The following cases may happen:<ul>
<li>the command is installed,</li>
<li>the target add-on is not installed</li>
<li>the target add-on is installed, but the command is not supported,</li>
<li>the target add-on is installed, the command is supported, but the command version is incorrect. Refer to the <a class="el" href="group___add_on_add_on_communication.html#ga0e7fdba07a0c40e317f2fe39b41e3738">ACAPI_AddOnAddOnCommunication_Call</a> function to see the details of calling another add-on. Refer to the paper of the Communication Manager for more details. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">The following sample checks whether the services of the standard DWF In-Out add-on are currently available:</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</body>
</html>