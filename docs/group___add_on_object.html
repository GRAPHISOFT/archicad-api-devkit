<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Archicad C++ API" />
<meta property="og:image" content="logo.svg" />
<meta property="og:description" content="Archicad Development Kit Documentation, best practices, example codes and information hub." />
<meta property="og:url" content="https://archicadapi.graphisoft.com/documentation/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="logo.svg" />
<meta name="twitter:title" content="Archicad C++ API" />
<meta name="twitter:description" content="Archicad Development Kit Documentation, best practices, example codes and information hub." />
<!-- END twitter metadata -->
<title>Archicad 29 C++ API: Add-On Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="https://fonts.cdnfonts.com/css/proxima-nova-2" rel="stylesheet">
<link rel="icon" href="logo.svg" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Archicad 29 C++ API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group___add_on_object.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Add-On Objects</div></div>
</div><!--header-->
<div class="contents">

<p>Functions for creating, handling and deleting custom (Add-On specific), Teamwork-safe Add-On Objects. These Objects provide a safer way to handle custom data than the legacy ModulData.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control information of a custom data stored into the project database.  <a href="struct_a_p_i___addon_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae44aed8071f2f6001ba603a8abdb1cc6" id="r_gae44aed8071f2f6001ba603a8abdb1cc6"><td class="memItemLeft" align="right" valign="top">typedef GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae44aed8071f2f6001ba603a8abdb1cc6">APIAddonObjectSaveOldFormatHandlerProc</a>(<a class="el" href="group___project_operation.html#gaf7e72c240d18c9af9200eada2ef2944b">API_FTypeID</a> planFileType, const GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;currentFormatAddOnObjectArray, GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;oldFormatAddOnObjectArray)</td></tr>
<tr class="memdesc:gae44aed8071f2f6001ba603a8abdb1cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">User supplied callback procedure for converting AddOnObjects into previous format.  <br /></td></tr>
<tr class="separator:gae44aed8071f2f6001ba603a8abdb1cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8010963c96d6661a8fbdd37a3dcf5804" id="r_ga8010963c96d6661a8fbdd37a3dcf5804"><td class="memItemLeft" align="right" valign="top">typedef GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8010963c96d6661a8fbdd37a3dcf5804">APIAddonObjectConvertNewFormatHandlerProc</a>(<a class="el" href="group___project_operation.html#gaf7e72c240d18c9af9200eada2ef2944b">API_FTypeID</a> planFileType, const GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;oldFormatAddOnObjectArray, GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;currentFormatAddOnObjectArray)</td></tr>
<tr class="memdesc:ga8010963c96d6661a8fbdd37a3dcf5804"><td class="mdescLeft">&#160;</td><td class="mdescRight">User supplied callback procedure for converting AddOnObjects into current format.  <br /></td></tr>
<tr class="separator:ga8010963c96d6661a8fbdd37a3dcf5804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55aa6bf8813420bade1328a38f8e7716" id="r_ga55aa6bf8813420bade1328a38f8e7716"><td class="memItemLeft" align="right" valign="top">typedef GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga55aa6bf8813420bade1328a38f8e7716">APIAddonObjectMergeHandlerProc</a>(const GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;sourceAddOnObjectArray)</td></tr>
<tr class="memdesc:ga55aa6bf8813420bade1328a38f8e7716"><td class="mdescLeft">&#160;</td><td class="mdescRight">User supplied callback procedure for handling AddOnObject merge operations.  <br /></td></tr>
<tr class="separator:ga55aa6bf8813420bade1328a38f8e7716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga806cd9b9d61f71e19dbe4e6541af3f5c" id="r_ga806cd9b9d61f71e19dbe4e6541af3f5c"><td class="memItemLeft" align="right" valign="top"><a id="ga806cd9b9d61f71e19dbe4e6541af3f5c" name="ga806cd9b9d61f71e19dbe4e6541af3f5c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga806cd9b9d61f71e19dbe4e6541af3f5c">API_AddonObjectType</a> { <b>GeneralAddOnObject</b>
, <b>UniqueAddOnObject</b>
, <b>ClientOnlyAddOnObject</b>
 }</td></tr>
<tr class="memdesc:ga806cd9b9d61f71e19dbe4e6541af3f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the two types of an AddOnObject: general (non-unique) and unique. <br /></td></tr>
<tr class="separator:ga806cd9b9d61f71e19dbe4e6541af3f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga97e24e67ec25955d5e214e2b2f9b6c3a" id="r_ga97e24e67ec25955d5e214e2b2f9b6c3a"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> (void)</td></tr>
<tr class="memdesc:ga97e24e67ec25955d5e214e2b2f9b6c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the add-on to be called for merging and converting its custom data stored in AddOnObjects.  <br /></td></tr>
<tr class="separator:ga97e24e67ec25955d5e214e2b2f9b6c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e4d7f8d3345a62a773624af71425334" id="r_ga6e4d7f8d3345a62a773624af71425334"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e4d7f8d3345a62a773624af71425334">ACAPI_AddOnObject_InstallAddOnObjectMergeHandler</a> (<a class="el" href="#ga55aa6bf8813420bade1328a38f8e7716">APIAddonObjectMergeHandlerProc</a> *mergeHandlerProc)</td></tr>
<tr class="memdesc:ga6e4d7f8d3345a62a773624af71425334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a callback procedure for handling the AddOnObject merge operations.  <br /></td></tr>
<tr class="separator:ga6e4d7f8d3345a62a773624af71425334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98ed8a5d6ea2eb54ab51d23af1bb097" id="r_gaf98ed8a5d6ea2eb54ab51d23af1bb097"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf98ed8a5d6ea2eb54ab51d23af1bb097">ACAPI_AddOnObject_InstallAddOnObjectSaveOldFormatHandler</a> (<a class="el" href="#gae44aed8071f2f6001ba603a8abdb1cc6">APIAddonObjectSaveOldFormatHandlerProc</a> *saveOldFormatProc)</td></tr>
<tr class="memdesc:gaf98ed8a5d6ea2eb54ab51d23af1bb097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a callback procedure for converting AddOnObject data into older format.  <br /></td></tr>
<tr class="separator:gaf98ed8a5d6ea2eb54ab51d23af1bb097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9aacf50e6bec4ec19f1f21929033493" id="r_gae9aacf50e6bec4ec19f1f21929033493"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9aacf50e6bec4ec19f1f21929033493">ACAPI_AddOnObject_InstallAddOnObjectConvertNewFormatHandler</a> (<a class="el" href="#ga8010963c96d6661a8fbdd37a3dcf5804">APIAddonObjectConvertNewFormatHandlerProc</a> *convertNewFormatProc)</td></tr>
<tr class="memdesc:gae9aacf50e6bec4ec19f1f21929033493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a callback procedure for converting old format AddOnObject data into current format.  <br /></td></tr>
<tr class="separator:gae9aacf50e6bec4ec19f1f21929033493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaea4e5746457e8aa76bb203b5ceaba7" id="r_gafaea4e5746457e8aa76bb203b5ceaba7"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafaea4e5746457e8aa76bb203b5ceaba7">ACAPI_AddOnObject_CreateObject</a> (const GS::UniString &amp;objectName, const GSHandle &amp;content, <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *objectGuid)</td></tr>
<tr class="memdesc:gafaea4e5746457e8aa76bb203b5ceaba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AddOnObject.  <br /></td></tr>
<tr class="separator:gafaea4e5746457e8aa76bb203b5ceaba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d960680dae4f2a32baaaadc83f3743" id="r_gaa4d960680dae4f2a32baaaadc83f3743"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa4d960680dae4f2a32baaaadc83f3743">ACAPI_AddOnObject_CreateUniqueObject</a> (const GS::UniString &amp;objectName, <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *objectGuid)</td></tr>
<tr class="memdesc:gaa4d960680dae4f2a32baaaadc83f3743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Unique AddOnObject.  <br /></td></tr>
<tr class="separator:gaa4d960680dae4f2a32baaaadc83f3743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa4df76c4d00c90e69fbb6f2fc91dc3" id="r_ga0fa4df76c4d00c90e69fbb6f2fc91dc3"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0fa4df76c4d00c90e69fbb6f2fc91dc3">ACAPI_AddOnObject_CreateUniqueObjectMore</a> (const GS::Array&lt; GS::UniString &gt; &amp;objectNames, GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;objectGuids)</td></tr>
<tr class="memdesc:ga0fa4df76c4d00c90e69fbb6f2fc91dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates more Unique AddOnObjects.  <br /></td></tr>
<tr class="separator:ga0fa4df76c4d00c90e69fbb6f2fc91dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada03dc9c7216883c1d9288e93e92b6c5" id="r_gada03dc9c7216883c1d9288e93e92b6c5"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada03dc9c7216883c1d9288e93e92b6c5">ACAPI_AddOnObject_CreateClientOnlyObject</a> (const GS::UniString &amp;objectName, const GSHandle &amp;content, <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *objectGuid)</td></tr>
<tr class="memdesc:gada03dc9c7216883c1d9288e93e92b6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AddOnObject.  <br /></td></tr>
<tr class="separator:gada03dc9c7216883c1d9288e93e92b6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga837dffdc10718017ab395b765512c7fc" id="r_ga837dffdc10718017ab395b765512c7fc"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga837dffdc10718017ab395b765512c7fc">ACAPI_AddOnObject_GetObjectList</a> (GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; *objects)</td></tr>
<tr class="memdesc:ga837dffdc10718017ab395b765512c7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of the AddOnObjects.  <br /></td></tr>
<tr class="separator:ga837dffdc10718017ab395b765512c7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd693da26f962e265383c83d8e02fbcb" id="r_gadd693da26f962e265383c83d8e02fbcb"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd693da26f962e265383c83d8e02fbcb">ACAPI_AddOnObject_GetObjectContent</a> (const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;objectGuid, GS::UniString *objectName, GSHandle *objectContent)</td></tr>
<tr class="memdesc:gadd693da26f962e265383c83d8e02fbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the content and the name of the specified AddOnObject from the project database.  <br /></td></tr>
<tr class="separator:gadd693da26f962e265383c83d8e02fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe6d5cd2f42b1f4b63d5f9a82f526d1" id="r_ga9fe6d5cd2f42b1f4b63d5f9a82f526d1"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9fe6d5cd2f42b1f4b63d5f9a82f526d1">ACAPI_AddOnObject_ModifyObject</a> (const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;objectGuid, const GS::UniString *newObjectName, const GSHandle *newObjectContent)</td></tr>
<tr class="memdesc:ga9fe6d5cd2f42b1f4b63d5f9a82f526d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the content and/or the name of the specified AddOnObject.  <br /></td></tr>
<tr class="separator:ga9fe6d5cd2f42b1f4b63d5f9a82f526d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac564a2674f44f150be4db68ffd85cbc" id="r_gaac564a2674f44f150be4db68ffd85cbc"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac564a2674f44f150be4db68ffd85cbc">ACAPI_AddOnObject_DeleteObject</a> (const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;objectGuid)</td></tr>
<tr class="memdesc:gaac564a2674f44f150be4db68ffd85cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an attribute from the database.  <br /></td></tr>
<tr class="separator:gaac564a2674f44f150be4db68ffd85cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb461934bcd1b65fdae2eefe93bfa599" id="r_gadb461934bcd1b65fdae2eefe93bfa599"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadb461934bcd1b65fdae2eefe93bfa599">ACAPI_AddOnObject_GetObjectGuidFromName</a> (const GS::UniString &amp;name, <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *objectGuid)</td></tr>
<tr class="memdesc:gadb461934bcd1b65fdae2eefe93bfa599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GUID of the specified object.  <br /></td></tr>
<tr class="separator:gadb461934bcd1b65fdae2eefe93bfa599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4976dfba6d525ed2a1f76888e0409f6" id="r_gaa4976dfba6d525ed2a1f76888e0409f6"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa4976dfba6d525ed2a1f76888e0409f6">ACAPI_AddOnObject_GetUniqueObjectGuidFromName</a> (const GS::UniString &amp;name, <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *objectGuid)</td></tr>
<tr class="memdesc:gaa4976dfba6d525ed2a1f76888e0409f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GUID of the specified Unique AddOnObject.  <br /></td></tr>
<tr class="separator:gaa4976dfba6d525ed2a1f76888e0409f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762181cb51af204fbe5065f9667404c5" id="r_ga762181cb51af204fbe5065f9667404c5"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga762181cb51af204fbe5065f9667404c5">ACAPI_AddOnObject_GetClientOnlyObjectGuidFromName</a> (const GS::UniString &amp;name, <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *objectGuid)</td></tr>
<tr class="memdesc:ga762181cb51af204fbe5065f9667404c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GUID of the specified object.  <br /></td></tr>
<tr class="separator:ga762181cb51af204fbe5065f9667404c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e07012bf57649cef42b82237ab2bc3" id="r_ga04e07012bf57649cef42b82237ab2bc3"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04e07012bf57649cef42b82237ab2bc3">ACAPI_AddOnObject_ReserveObjects</a> (const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;objectGuids, GS::HashTable&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a>, short &gt; *conflicts)</td></tr>
<tr class="memdesc:ga04e07012bf57649cef42b82237ab2bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In teamwork mode this function reserves the specified objects.  <br /></td></tr>
<tr class="separator:ga04e07012bf57649cef42b82237ab2bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685ae0a4af791e1240c5c317bb2b71ec" id="r_ga685ae0a4af791e1240c5c317bb2b71ec"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga685ae0a4af791e1240c5c317bb2b71ec">ACAPI_AddOnObject_ReleaseObjects</a> (const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;objectGuids)</td></tr>
<tr class="memdesc:ga685ae0a4af791e1240c5c317bb2b71ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">In teamwork mode this function releases the specified objects.  <br /></td></tr>
<tr class="separator:ga685ae0a4af791e1240c5c317bb2b71ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec5a52f403966a9136859b9a3c8e19c" id="r_gafec5a52f403966a9136859b9a3c8e19c"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafec5a52f403966a9136859b9a3c8e19c">ACAPI_AddOnObject_RequestObjects</a> (const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;objectGuids, const GS::UniString &amp;mailText)</td></tr>
<tr class="memdesc:gafec5a52f403966a9136859b9a3c8e19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In teamwork mode this function sends a request mail in order to request the specified objects from the owners.  <br /></td></tr>
<tr class="separator:gafec5a52f403966a9136859b9a3c8e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0bc5d47547bfc70c2fcec30e87d87d" id="r_ga3e0bc5d47547bfc70c2fcec30e87d87d"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3e0bc5d47547bfc70c2fcec30e87d87d">ACAPI_AddOnObject_GrantObjects</a> (const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;objectGuids, short toUserId)</td></tr>
<tr class="memdesc:ga3e0bc5d47547bfc70c2fcec30e87d87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In teamwork mode this function grants the specified objects to the given user.  <br /></td></tr>
<tr class="separator:ga3e0bc5d47547bfc70c2fcec30e87d87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4286d2ad95ee976cd1642d86abe55b08" id="r_ga4286d2ad95ee976cd1642d86abe55b08"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4286d2ad95ee976cd1642d86abe55b08">ACAPI_AddOnObject_GetTeamworkOwnerId</a> (const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;objectGuid, short *ownerId)</td></tr>
<tr class="memdesc:ga4286d2ad95ee976cd1642d86abe55b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ownerId of the specified object in teamwork mode.  <br /></td></tr>
<tr class="separator:ga4286d2ad95ee976cd1642d86abe55b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24de0e9abb3c27bafb5e8cc3527dad7e" id="r_ga24de0e9abb3c27bafb5e8cc3527dad7e"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga24de0e9abb3c27bafb5e8cc3527dad7e">ACAPI_AddOnObject_ExistsObject</a> (const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;objectGuid, bool *objectExists)</td></tr>
<tr class="memdesc:ga24de0e9abb3c27bafb5e8cc3527dad7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the project database contains the specified AddOnObject or not.  <br /></td></tr>
<tr class="separator:ga24de0e9abb3c27bafb5e8cc3527dad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02caa4564303ee142721d174f130aa37" id="r_ga02caa4564303ee142721d174f130aa37"><td class="memItemLeft" align="right" valign="top">GSErrCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga02caa4564303ee142721d174f130aa37">ACAPI_AddOnObject_SetUIProperties</a> (const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *objectGuid, const GS::UniString *name, const GS::UniString &amp;localisedName, short dialogMenuStringId)</td></tr>
<tr class="memdesc:ga02caa4564303ee142721d174f130aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets various UI properties of an AddOnObject.  <br /></td></tr>
<tr class="separator:ga02caa4564303ee142721d174f130aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for creating, handling and deleting custom (Add-On specific), Teamwork-safe Add-On Objects. These Objects provide a safer way to handle custom data than the legacy ModulData. </p>
<p>The AddOnData Manager is a service introduced in API v19.</p>
<p>It allows each add-on to store custom data in Archicad project database. No limitation is imposed on the structure or content, not even on the amount of saved bytes. Archicad knows nothing about its internal format, it just preserves a number of bytes in the project database and returns them upon requests.</p>
<p>The container of the stored data is an object called AddOnObject. This data structure has a GUID and a name. The name is optional.</p>
<p>AddOnobjects are identified uniquely by the GUID of the object.</p>
<h1><a class="anchor" id="autotoc_md87"></a>
Unique AddOnObjects</h1>
<p>Unique AddOnObjects were introduced to support more restricted but safer TeamWork behaviour. Because multiple general (non-unique) AddOnObjects can exist with the same name, in TeamWork it could happen that two users created "the same" AddOnObject simultaneously, but at the end they ended up with two different AddOnObjects (with the same name). This led to a lot of confusion.</p>
<p>With Unique AddOnObjects - like general AddOnObjects - you can store custom data in the project database. However - unlike general AddOnObjects - their names must be and will be unique among each other. Please note that names of a Unique AddOnObject and general AddOnObjects may still be equal.</p>
<p>In a TeamWork project creating Unique AddOnObjects will result in a Full Send to ensure project consistency. Due to this inconvenience, it is possible to create more Unique AddOnObjects at once with the <a class="el" href="#ga0fa4df76c4d00c90e69fbb6f2fc91dc3">ACAPI_AddOnObject_CreateUniqueObjectMore</a> function.</p>
<p>All functions that work for general AddOnObjects work for Unique AddOnObjects, too, except <a class="el" href="#gadb461934bcd1b65fdae2eefe93bfa599">ACAPI_AddOnObject_GetObjectGuidFromName</a> : to get the GUID of a Unique AddOnObject from its name use <a class="el" href="#gaa4976dfba6d525ed2a1f76888e0409f6">ACAPI_AddOnObject_GetUniqueObjectGuidFromName</a> instead.</p>
<h1><a class="anchor" id="autotoc_md88"></a>
Functions</h1>
<p>All of the ModulData Manager functions begin with the <b>ACAPI_AddOnObject_</b> prefix. They are as follows:</p>
<ul>
<li><a class="el" href="#gafaea4e5746457e8aa76bb203b5ceaba7">ACAPI_AddOnObject_CreateObject</a></li>
<li><a class="el" href="#gada03dc9c7216883c1d9288e93e92b6c5">ACAPI_AddOnObject_CreateClientOnlyObject</a></li>
<li><a class="el" href="#gaa4d960680dae4f2a32baaaadc83f3743">ACAPI_AddOnObject_CreateUniqueObject</a></li>
<li><a class="el" href="#ga0fa4df76c4d00c90e69fbb6f2fc91dc3">ACAPI_AddOnObject_CreateUniqueObjectMore</a></li>
<li><a class="el" href="#ga9fe6d5cd2f42b1f4b63d5f9a82f526d1">ACAPI_AddOnObject_ModifyObject</a></li>
<li><a class="el" href="#gaac564a2674f44f150be4db68ffd85cbc">ACAPI_AddOnObject_DeleteObject</a></li>
<li><a class="el" href="#ga837dffdc10718017ab395b765512c7fc">ACAPI_AddOnObject_GetObjectList</a></li>
<li><a class="el" href="#gadd693da26f962e265383c83d8e02fbcb">ACAPI_AddOnObject_GetObjectContent</a></li>
<li><a class="el" href="#gadb461934bcd1b65fdae2eefe93bfa599">ACAPI_AddOnObject_GetObjectGuidFromName</a></li>
<li><a class="el" href="#ga762181cb51af204fbe5065f9667404c5">ACAPI_AddOnObject_GetClientOnlyObjectGuidFromName</a></li>
<li><a class="el" href="#gaa4976dfba6d525ed2a1f76888e0409f6">ACAPI_AddOnObject_GetUniqueObjectGuidFromName</a></li>
<li><a class="el" href="#ga24de0e9abb3c27bafb5e8cc3527dad7e">ACAPI_AddOnObject_ExistsObject</a></li>
<li><a class="el" href="#ga04e07012bf57649cef42b82237ab2bc3">ACAPI_AddOnObject_ReserveObjects</a></li>
<li><a class="el" href="#ga685ae0a4af791e1240c5c317bb2b71ec">ACAPI_AddOnObject_ReleaseObjects</a></li>
<li><a class="el" href="#gafec5a52f403966a9136859b9a3c8e19c">ACAPI_AddOnObject_RequestObjects</a></li>
<li><a class="el" href="#ga3e0bc5d47547bfc70c2fcec30e87d87d">ACAPI_AddOnObject_GrantObjects</a></li>
<li><a class="el" href="#ga4286d2ad95ee976cd1642d86abe55b08">ACAPI_AddOnObject_GetTeamworkOwnerId</a></li>
<li><a class="el" href="#ga02caa4564303ee142721d174f130aa37">ACAPI_AddOnObject_SetUIProperties</a></li>
</ul>
<p>Refer to the <b>AddOnObject Manager</b> example project to see detailed examples on using these functions.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
Merging AddOnObjects</h1>
<p>When merging another plan into the project, it might be necessary to keep both the original and the incoming objects, and to combine them together. Since the host application does not know the content of the objects, the owner add-on is requested to resolve the conflict.</p>
<p>For this purpose the add-on needs to implement an <code>APIAddOnObjectMergeHandlerProc</code> callback handler function, and pass the function pointer to Archicad with the For this purpose the add-on needs to implement an <code>APIAddOnObjectMergeHandlerProc</code> callback handler function, and pass the function pointer to Archicad with the <a class="el" href="#ga6e4d7f8d3345a62a773624af71425334">ACAPI_AddOnObject_InstallAddOnObjectMergeHandler</a> in the <a class="el" href="group___add_on_lifetime.html#gaa8f1f7d553305c1afe5de7e4dcb66e99">Initialize</a> routine. It is also necessary to inform Archicad that the add-on is prepared for merging custom data: this can be done with the <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> function called from <a class="el" href="group___add_on_lifetime.html#ga3d5b6a23422e44dce66728b0f4eb943e">RegisterInterface</a>. <a class="el" href="#ga6e4d7f8d3345a62a773624af71425334">ACAPI_AddOnObject_InstallAddOnObjectMergeHandler</a> in the <a class="el" href="group___add_on_lifetime.html#gaa8f1f7d553305c1afe5de7e4dcb66e99">Initialize</a> routine. It is also necessary to inform Archicad that the add-on is prepared for merging custom data: this can be done with the <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> function called from <a class="el" href="group___add_on_lifetime.html#ga3d5b6a23422e44dce66728b0f4eb943e">RegisterInterface</a>.</p>
<p>In Teamwork mode the AddOnObject can only be modified by the owner of the object. The add-on can reserve or release one or more AddOnObject using <a class="el" href="#ga04e07012bf57649cef42b82237ab2bc3">ACAPI_AddOnObject_ReserveObjects</a> and <a class="el" href="#ga685ae0a4af791e1240c5c317bb2b71ec">ACAPI_AddOnObject_ReleaseObjects</a>. Only one user can modifiy an object at one time, so no conflict resolution is needed.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
Saving data into old format project</h1>
<p>If the structure of the custom data has changed since the previous version, you need to implement an <a class="el" href="#gae44aed8071f2f6001ba603a8abdb1cc6">APIAddonObjectSaveOldFormatHandlerProc</a> callback function to be able to convert your data when saving into an older format project. In order to be called this handler, the function pointer must be passed with <a class="el" href="#gaf98ed8a5d6ea2eb54ab51d23af1bb097">ACAPI_AddOnObject_InstallAddOnObjectSaveOldFormatHandler</a>, and the data handling feature must be registered with <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a>.</p>
<p>When Archicad calls this function, the add-on should create the converted data according to the given plan file format, and pass it back to the application.</p>
<p>If the add-on does not install this converter callback routine, the available current format data is saved into the old version project as well.</p>
<h1><a class="anchor" id="autotoc_md91"></a>
Converting data when reading an old format project</h1>
<p>If the structure of the custom data has changed since the older versions, you need to implement an <code>APIAddonObjectConvertNewFormatHandlerProc</code> callback function to be able to convert your data when opening an older format project. In order to be called this handler, the function pointer must be passed with <a class="el" href="#gae9aacf50e6bec4ec19f1f21929033493">ACAPI_AddOnObject_InstallAddOnObjectConvertNewFormatHandler</a>, and registration with <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> is also needed.</p>
<p>When Archicad calls this function, the add-on should create the current version data, and pass it back to the application.</p>
<p>If the add-on does not install this converter callback routine, the available orignal format data will be kept in the current version project as well. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8010963c96d6661a8fbdd37a3dcf5804" name="ga8010963c96d6661a8fbdd37a3dcf5804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8010963c96d6661a8fbdd37a3dcf5804">&#9670;&#160;</a></span>APIAddonObjectConvertNewFormatHandlerProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef GSErrCode APIAddonObjectConvertNewFormatHandlerProc(<a class="el" href="group___project_operation.html#gaf7e72c240d18c9af9200eada2ef2944b">API_FTypeID</a> planFileType, const GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;oldFormatAddOnObjectArray, GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;currentFormatAddOnObjectArray)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User supplied callback procedure for converting AddOnObjects into current format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">planFileType</td><td>[in] The original version of the plan of the project is being opened. </td></tr>
    <tr><td class="paramname">oldFormatAddOnObjectArray</td><td>[in] AddOnObject data in original format. </td></tr>
    <tr><td class="paramname">currentFormatAddOnObjectArray</td><td>[out] Array for the converted AddOnObject data in current format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to convert the add-on's AddOnObject data into current format, you need to implement this callback function, and pass it to Archicad with <a class="el" href="#gae9aacf50e6bec4ec19f1f21929033493">ACAPI_AddOnObject_InstallAddOnObjectConvertNewFormatHandler</a> during the <a class="el" href="group___add_on_lifetime.html#gaa8f1f7d553305c1afe5de7e4dcb66e99">Initialize</a> phase. It is also necessary to notify Archicad about this capability of the add-on by calling <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> from the <a class="el" href="group___add_on_lifetime.html#ga3d5b6a23422e44dce66728b0f4eb943e">RegisterInterface</a> function. </dd></dl>

</div>
</div>
<a id="ga55aa6bf8813420bade1328a38f8e7716" name="ga55aa6bf8813420bade1328a38f8e7716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55aa6bf8813420bade1328a38f8e7716">&#9670;&#160;</a></span>APIAddonObjectMergeHandlerProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef GSErrCode APIAddonObjectMergeHandlerProc(const GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;sourceAddOnObjectArray)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User supplied callback procedure for handling AddOnObject merge operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceAddOnObjectArray</td><td>[in] The list of the source AddOnObjects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is the function to be called when a file merge operation is performed. The handler function should merge the source objects into the project database by calling AddOnObject-related API functions (e.g. <a class="el" href="#ga9fe6d5cd2f42b1f4b63d5f9a82f526d1">ACAPI_AddOnObject_ModifyObject</a>). </dd></dl>

</div>
</div>
<a id="gae44aed8071f2f6001ba603a8abdb1cc6" name="gae44aed8071f2f6001ba603a8abdb1cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae44aed8071f2f6001ba603a8abdb1cc6">&#9670;&#160;</a></span>APIAddonObjectSaveOldFormatHandlerProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef GSErrCode APIAddonObjectSaveOldFormatHandlerProc(<a class="el" href="group___project_operation.html#gaf7e72c240d18c9af9200eada2ef2944b">API_FTypeID</a> planFileType, const GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;currentFormatAddOnObjectArray, GS::Array&lt; <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> &gt; &amp;oldFormatAddOnObjectArray)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User supplied callback procedure for converting AddOnObjects into previous format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">planFileType</td><td>[in] The old format plan version the project is being saved. </td></tr>
    <tr><td class="paramname">currentFormatAddOnObjectArray</td><td>[in] AddOnObject data in current format. </td></tr>
    <tr><td class="paramname">oldFormatAddOnObjectArray</td><td>[out] Array for the converted AddOnObject data in old format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to save the add-on's AddOnObject data in the proper format into a previous version project file, you need to implement this callback function, and pass it to Archicad with <a class="el" href="#gaf98ed8a5d6ea2eb54ab51d23af1bb097">ACAPI_AddOnObject_InstallAddOnObjectSaveOldFormatHandler</a> during the Initialize phase. It is also necessary to notify Archicad about this capability of the add-on by calling <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> from the RegisterInterface function. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gada03dc9c7216883c1d9288e93e92b6c5" name="gada03dc9c7216883c1d9288e93e92b6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada03dc9c7216883c1d9288e93e92b6c5">&#9670;&#160;</a></span>ACAPI_AddOnObject_CreateClientOnlyObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_CreateClientOnlyObject </td>
          <td>(</td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>objectName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GSHandle &amp;</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an AddOnObject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectName</td><td>[in] The name of the AddOnObject. </td></tr>
    <tr><td class="paramname">content</td><td>[in] The content of the AddOnObject. </td></tr>
    <tr><td class="paramname">objectGuid</td><td>[out] The GUID of the created object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to store custom data into project database. The custom data is represented by AddOnObject. This data is avaible in teamwork only in clinet side, it won't be send to the teamwork server. If you need to ensure that the AddOnObject send between users use <a class="el" href="#gafaea4e5746457e8aa76bb203b5ceaba7">ACAPI_AddOnObject_CreateObject</a>. The content handle will be copied inside the function so it has to be deleted after the function call. The stored data can be accessed using objectGuid parameter. The objectName parameter can also be used for identifying the custom data. It can be also emtpy. Archicad does not check if the name is unique. If you need to ensure that only one AddOnObject exists with the same name, then use Unique AddOnObjects. See more: <a class="el" href="#gaa4d960680dae4f2a32baaaadc83f3743">ACAPI_AddOnObject_CreateUniqueObject</a>. The content handle will be copied inside the function so it has to be deleted after the function call. The stored data can be accessed using objectGuid parameter. The objectName parameter can also be used for identifying the custom data. It can be also emtpy. Archicad does not check if the name is unique. If you need to ensure that only one AddOnObject exists with the same name, then use Unique AddOnObjects. See more: <a class="el" href="#gaa4d960680dae4f2a32baaaadc83f3743">ACAPI_AddOnObject_CreateUniqueObject</a>. </dd></dl>

</div>
</div>
<a id="gafaea4e5746457e8aa76bb203b5ceaba7" name="gafaea4e5746457e8aa76bb203b5ceaba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaea4e5746457e8aa76bb203b5ceaba7">&#9670;&#160;</a></span>ACAPI_AddOnObject_CreateObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_CreateObject </td>
          <td>(</td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>objectName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GSHandle &amp;</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an AddOnObject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectName</td><td>[in] The name of the AddOnObject. </td></tr>
    <tr><td class="paramname">content</td><td>[in] The content of the AddOnObject. </td></tr>
    <tr><td class="paramname">objectGuid</td><td>[out] The GUID of the created object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to store custom data into project database. The custom data is represented by AddOnObject. This data is avaible in teamwork only in clinet side, it won't be send to the teamwork server. If you need to ensure that the AddOnObject send between users use <a class="el" href="#gafaea4e5746457e8aa76bb203b5ceaba7">ACAPI_AddOnObject_CreateObject</a>. The content handle will be copied inside the function so it has to be deleted after the function call. The stored data can be accessed using objectGuid parameter. The objectName parameter can also be used for identifying the custom data. It can be also emtpy. Archicad does not check if the name is unique. If you need to ensure that only one AddOnObject exists with the same name, then use Unique AddOnObjects. See more: <a class="el" href="#gaa4d960680dae4f2a32baaaadc83f3743">ACAPI_AddOnObject_CreateUniqueObject</a>. The content handle will be copied inside the function so it has to be deleted after the function call. The stored data can be accessed using objectGuid parameter. The objectName parameter can also be used for identifying the custom data. It can be also emtpy. Archicad does not check if the name is unique. If you need to ensure that only one AddOnObject exists with the same name, then use Unique AddOnObjects. See more: <a class="el" href="#gaa4d960680dae4f2a32baaaadc83f3743">ACAPI_AddOnObject_CreateUniqueObject</a>. </dd></dl>

</div>
</div>
<a id="gaa4d960680dae4f2a32baaaadc83f3743" name="gaa4d960680dae4f2a32baaaadc83f3743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d960680dae4f2a32baaaadc83f3743">&#9670;&#160;</a></span>ACAPI_AddOnObject_CreateUniqueObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_CreateUniqueObject </td>
          <td>(</td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>objectName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Unique AddOnObject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectName</td><td>[in] The name of the Unique AddOnObject. </td></tr>
    <tr><td class="paramname">objectGuid</td><td>[out] The GUID of the created object. Value is undefined if an error happened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_CANCEL - If the user refused to Send Receive all changes.</li>
<li>APIERR_NAMEALREADYUSED - If there is already a Unique AddOnObject with the given objectName.</li>
<li>APIERR_NOTEAMWORKPROJECT - Indicates that the project is an Offline TeamWork project. Due to possible conflicts, it is not allowed to create Unique AddOnObjects in an Offline Teamwork Project.</li>
<li>APIERR_SERVICEFAILED - The created Unique AddOnObject could not be sent to the TeamWork server. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unique AddOnObjects were introduced to support more restricted but safer TeamWork behaviour. Because multiple general (non-unique) AddOnObjects can exist with the same name, in TeamWork it could happen that two users created "the same" AddOnObject simultaneously, but at the end they ended up with two different AddOnObjects. This led to a lot of confusion. With Unique AddOnObjects - like general AddOnObjects - you can store custom data in the project database. However - unlike general AddOnObjects - their names must be and will be unique among each other. Please note that names of a Unique AddOnObject and general AddOnObjects may be equal. In a TeamWork project creating Unique AddOnObjects will result in a Full Receive and a Full Send to ensure project consistency. Due to this inconvenience, it is possible to create more Unique AddOnObjects at once with the <a class="el" href="#ga0fa4df76c4d00c90e69fbb6f2fc91dc3">ACAPI_AddOnObject_CreateUniqueObjectMore</a> function. Unlike general AddOnObjects - to ensure no data conflict occurs - it is not possible to give default content to a Unique AddOnObject. To do so, you must call <a class="el" href="#ga9fe6d5cd2f42b1f4b63d5f9a82f526d1">ACAPI_AddOnObject_ModifyObject</a> function. The stored data can be accessed using the returned objectGuid. All functions that work for general AddOnObjects work for Unique AddOnObjects, too, except <a class="el" href="#gadb461934bcd1b65fdae2eefe93bfa599">ACAPI_AddOnObject_GetObjectGuidFromName</a> : to get the GUID of a Unique AddOnObject from its name use <a class="el" href="#gaa4976dfba6d525ed2a1f76888e0409f6">ACAPI_AddOnObject_GetUniqueObjectGuidFromName</a> instead. </dd></dl>

</div>
</div>
<a id="ga0fa4df76c4d00c90e69fbb6f2fc91dc3" name="ga0fa4df76c4d00c90e69fbb6f2fc91dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa4df76c4d00c90e69fbb6f2fc91dc3">&#9670;&#160;</a></span>ACAPI_AddOnObject_CreateUniqueObjectMore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_CreateUniqueObjectMore </td>
          <td>(</td>
          <td class="paramtype">const GS::Array&lt; GS::UniString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>objectNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuids</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates more Unique AddOnObjects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectNames</td><td>[in] The names of the Unique AddOnObjects. The names must be unique. </td></tr>
    <tr><td class="paramname">objectGuids</td><td>[out] The GUIDs of the created objects. One guid is returned to each given name. Empty array is returned if an error happened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - If the objectNames array is empty or the names in it are not unique among each other.</li>
<li>APIERR_NAMEALREADYUSED - If there is already a Unique AddOnObject with one of the given objectNames.</li>
<li>APIERR_NOTEAMWORKPROJECT - Indicates that the project is an Offline TeamWork project. Due to possible conflicts, it is not allowed to create Unique AddOnObjects in an Offline Teamwork Project.</li>
<li>APIERR_SERVICEFAILED - The created Unique AddOnObjects could not be sent to the TeamWork server. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In a TeamWork project creating Unique AddOnObjects will result in a Full Receive and a Full Send to ensure project consistency. Due to this inconvenience, it is possible to create more Unique AddOnObjects at once with this function. For more info, see <a class="el" href="#gaa4d960680dae4f2a32baaaadc83f3743">ACAPI_AddOnObject_CreateUniqueObject</a>. </dd></dl>

</div>
</div>
<a id="gaac564a2674f44f150be4db68ffd85cbc" name="gaac564a2674f44f150be4db68ffd85cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac564a2674f44f150be4db68ffd85cbc">&#9670;&#160;</a></span>ACAPI_AddOnObject_DeleteObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_DeleteObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an attribute from the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuid</td><td>[in] The GUID of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADID - The object does not exist.</li>
<li>APIERR_NOTMINE - The object is not owned by the current user in teamwork mode. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to delete an AddOnObject from the project database. </dd></dl>

</div>
</div>
<a id="ga24de0e9abb3c27bafb5e8cc3527dad7e" name="ga24de0e9abb3c27bafb5e8cc3527dad7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24de0e9abb3c27bafb5e8cc3527dad7e">&#9670;&#160;</a></span>ACAPI_AddOnObject_ExistsObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_ExistsObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>objectExists</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the project database contains the specified AddOnObject or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuid</td><td>[in] The GUID of the specified object.. </td></tr>
    <tr><td class="paramname">objectExists</td><td>[out] true if the object exists, otherwise false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuid is APINULLGuid or objectExists is nullptr</li>
<li>APIERR_BADID - The object specified by GUID exists, but its type is not AddOnObject. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga762181cb51af204fbe5065f9667404c5" name="ga762181cb51af204fbe5065f9667404c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762181cb51af204fbe5065f9667404c5">&#9670;&#160;</a></span>ACAPI_AddOnObject_GetClientOnlyObjectGuidFromName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_GetClientOnlyObjectGuidFromName </td>
          <td>(</td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the GUID of the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>[in] The name of the specified object. </td></tr>
    <tr><td class="paramname">objectGuid</td><td>[out] The GUID of the object, if the project database contains AddOnObject with the specified name, otherwise APINULLGuid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuid is nullptr. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If more AddOnObjects exist with the same name, it is not specified which GUID will be returned. Please note that this is a linear time function. This function cannot be used to get the GUID of a Unique AddOnObject or AddOnObject or the get GUID-s from other teamwork users. You can use Unique AddOnObjects if it is important to have only one AddOnObject with the same name. See AddOnObject Manager for more information. Please note that this is a linear time function. This function cannot be used to get the GUID of a Unique AddOnObject. You can use Unique AddOnObjects if it is important to have only one AddOnObject with the same name. See AddOnObject Manager for more information. </dd></dl>

</div>
</div>
<a id="gadd693da26f962e265383c83d8e02fbcb" name="gadd693da26f962e265383c83d8e02fbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd693da26f962e265383c83d8e02fbcb">&#9670;&#160;</a></span>ACAPI_AddOnObject_GetObjectContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_GetObjectContent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GS::UniString *</td>          <td class="paramname"><span class="paramname"><em>objectName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GSHandle *</td>          <td class="paramname"><span class="paramname"><em>objectContent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the content and the name of the specified AddOnObject from the project database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuid</td><td>[in] The GUID of the object. </td></tr>
    <tr><td class="paramname">objectName</td><td>[out] The name of the specified object. </td></tr>
    <tr><td class="paramname">objectContent</td><td>[out] The content of the specified object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuid is APINULLGuid or either objectName or objectContent is nullptr.</li>
<li>APIERR_BADID - No object with the specified GUID exists. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Archicad allocates the target buffer in content parameter; the caller add-on is responsible to dispose it with BMKillHandle. </dd></dl>

</div>
</div>
<a id="gadb461934bcd1b65fdae2eefe93bfa599" name="gadb461934bcd1b65fdae2eefe93bfa599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb461934bcd1b65fdae2eefe93bfa599">&#9670;&#160;</a></span>ACAPI_AddOnObject_GetObjectGuidFromName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_GetObjectGuidFromName </td>
          <td>(</td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the GUID of the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>[in] The name of the specified object. </td></tr>
    <tr><td class="paramname">objectGuid</td><td>[out] The GUID of the object, if the project database contains AddOnObject with the specified name, otherwise APINULLGuid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuid is nullptr. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If more AddOnObjects exist with the same name, it is not specified which GUID will be returned. Please note that this is a linear time function. This function cannot be used to get the GUID of a Unique AddOnObject or AddOnObject or the get GUID-s from other teamwork users. You can use Unique AddOnObjects if it is important to have only one AddOnObject with the same name. See AddOnObject Manager for more information. Please note that this is a linear time function. This function cannot be used to get the GUID of a Unique AddOnObject. You can use Unique AddOnObjects if it is important to have only one AddOnObject with the same name. See AddOnObject Manager for more information. </dd></dl>

</div>
</div>
<a id="ga837dffdc10718017ab395b765512c7fc" name="ga837dffdc10718017ab395b765512c7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga837dffdc10718017ab395b765512c7fc">&#9670;&#160;</a></span>ACAPI_AddOnObject_GetObjectList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_GetObjectList </td>
          <td>(</td>
          <td class="paramtype">GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>objects</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of the AddOnObjects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>[out] This array will be filled with the GUIDs of the AddOnObjects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objects is nullptr </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function returns both general and Unique AddOnObjects. </dd></dl>

</div>
</div>
<a id="ga4286d2ad95ee976cd1642d86abe55b08" name="ga4286d2ad95ee976cd1642d86abe55b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4286d2ad95ee976cd1642d86abe55b08">&#9670;&#160;</a></span>ACAPI_AddOnObject_GetTeamworkOwnerId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_GetTeamworkOwnerId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *</td>          <td class="paramname"><span class="paramname"><em>ownerId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ownerId of the specified object in teamwork mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuid</td><td>[in] The GUID of the specified object. </td></tr>
    <tr><td class="paramname">ownerId</td><td>[out] The teamwork owner user of the specified object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuid is APINULLGuid or ownerId is nullptr</li>
<li>APIERR_BADID - AddOnObject does not exist. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa4976dfba6d525ed2a1f76888e0409f6" name="gaa4976dfba6d525ed2a1f76888e0409f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4976dfba6d525ed2a1f76888e0409f6">&#9670;&#160;</a></span>ACAPI_AddOnObject_GetUniqueObjectGuidFromName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_GetUniqueObjectGuidFromName </td>
          <td>(</td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the GUID of the specified Unique AddOnObject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>[in] The name of the specified object. </td></tr>
    <tr><td class="paramname">objectGuid</td><td>[out] The GUID of the object, if the project database contains Unique AddOnObject with the specified name, otherwise APINULLGuid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuid is NULL. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function cannot be used to get the GUID of a general (non-unique) AddOnObject. Please note that this is a linear time function. This function cannot be used to get the GUID of a general (non-unique) AddOnObject. </dd></dl>

</div>
</div>
<a id="ga3e0bc5d47547bfc70c2fcec30e87d87d" name="ga3e0bc5d47547bfc70c2fcec30e87d87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e0bc5d47547bfc70c2fcec30e87d87d">&#9670;&#160;</a></span>ACAPI_AddOnObject_GrantObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_GrantObjects </td>
          <td>(</td>
          <td class="paramtype">const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>toUserId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In teamwork mode this function grants the specified objects to the given user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuids</td><td>[in] The list of the objects which must be granted. </td></tr>
    <tr><td class="paramname">toUserId</td><td>[in] The teamwork owner, to which the objects must be granted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuids is empty or contains APINULLGuid.</li>
<li>APIERR_BADID - If any of the objectGuids is not an AddOnObject GUID. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the function has completed with success then the specified objects will be granted to the given user. The process runs in silent mode, no dialogs or messages will interrupt. </dd></dl>

</div>
</div>
<a id="gae9aacf50e6bec4ec19f1f21929033493" name="gae9aacf50e6bec4ec19f1f21929033493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9aacf50e6bec4ec19f1f21929033493">&#9670;&#160;</a></span>ACAPI_AddOnObject_InstallAddOnObjectConvertNewFormatHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_InstallAddOnObjectConvertNewFormatHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8010963c96d6661a8fbdd37a3dcf5804">APIAddonObjectConvertNewFormatHandlerProc</a> *</td>          <td class="paramname"><span class="paramname"><em>convertNewFormatProc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a callback procedure for converting old format AddOnObject data into current format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">convertNewFormatProc</td><td>[in] The callback procedure to convert AddOnObject data. Passing nullptr in this parameter uninstalls the previously installed handler function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to convert the add-on's AddOnObject data into current format, you need to implement this callback function, and pass it to Archicad with <a class="el" href="#gae9aacf50e6bec4ec19f1f21929033493">ACAPI_AddOnObject_InstallAddOnObjectConvertNewFormatHandler</a> during the Initialize phase. It is also necessary to notify Archicad about this capability of the add-on by calling <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> from the RegisterInterface function. This handler function is called whenever the user opens an old version project, and the add-on has any AddOnObject stored in the original project. The data should be constructed according to the current version into <code><a class="el" href="struct_a_p_i___addon_object.html" title="Control information of a custom data stored into the project database.">API_AddonObject</a></code> structures, and these structures should be pushed into the currentFormatAddOnObjectArray array. The memory allocated for the converted AddOnObject by the add-on's handler function will be released by the caller application. You must pay attention to not create more than one <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> s with the same name if the AddOnObject is Unique. </dd></dl>

</div>
</div>
<a id="ga6e4d7f8d3345a62a773624af71425334" name="ga6e4d7f8d3345a62a773624af71425334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e4d7f8d3345a62a773624af71425334">&#9670;&#160;</a></span>ACAPI_AddOnObject_InstallAddOnObjectMergeHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_InstallAddOnObjectMergeHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga55aa6bf8813420bade1328a38f8e7716">APIAddonObjectMergeHandlerProc</a> *</td>          <td class="paramname"><span class="paramname"><em>mergeHandlerProc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a callback procedure for handling the AddOnObject merge operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mergeHandlerProc</td><td>[in] The callback procedure which will handle the AddOnObject data merge. Can be nullptr ; this removes the installed callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function should be called in the Initialize function of your add-on to pass the pointer of the APIAddOnObjectMergeHandlerProc callback routine implemented for resolving conflicts between two lists of the AddOnObjects of the add-on during a merge operation. </dd></dl>

</div>
</div>
<a id="gaf98ed8a5d6ea2eb54ab51d23af1bb097" name="gaf98ed8a5d6ea2eb54ab51d23af1bb097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf98ed8a5d6ea2eb54ab51d23af1bb097">&#9670;&#160;</a></span>ACAPI_AddOnObject_InstallAddOnObjectSaveOldFormatHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_InstallAddOnObjectSaveOldFormatHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gae44aed8071f2f6001ba603a8abdb1cc6">APIAddonObjectSaveOldFormatHandlerProc</a> *</td>          <td class="paramname"><span class="paramname"><em>saveOldFormatProc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a callback procedure for converting AddOnObject data into older format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveOldFormatProc</td><td>[in] The callback procedure to convert AddOnObject data. Passing nullptr in this parameter uninstalls the previously installed handler function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to save the add-on's AddOnObject data in the proper format into a previous version project file, you need to implement this callback function, and pass it to Archicad with <a class="el" href="#gaf98ed8a5d6ea2eb54ab51d23af1bb097">ACAPI_AddOnObject_InstallAddOnObjectSaveOldFormatHandler</a> during the Initialize phase. It is also necessary to notify Archicad about this capability of the add-on by calling <a class="el" href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">ACAPI_AddOnObject_RegisterAddOnObjectHandler</a> from the <a class="el" href="group___add_on_lifetime.html#ga3d5b6a23422e44dce66728b0f4eb943e">RegisterInterface</a> function. This handler function is called whenever the user saves the project into an older format, and the add-on has any AddOnObject stored currently into the project. The data should be constructed according to the required version into <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> structures, and these structures should be pushed into the <code>oldFormatAddOnObjectArray</code> array. The memory allocated for the converted AddOnObjects by the add-on's handler function will be released by the caller application. If you need to delete an AddOnObject (e.g. it cannot be read by a previous version) then simply don't push it into the array. Order of the converted <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> s is irrelevant. You must pay attention to not create more than one <a class="el" href="struct_a_p_i___addon_object.html">API_AddonObject</a> s with the same name if the AddOnObject is Unique. Because Unique AddOnObjects is an API 21 () feature, please pay special attention to converting AddOnObjects with UniqueAddOnObject <a class="el" href="#ga806cd9b9d61f71e19dbe4e6541af3f5c">API_AddonObjectType</a> by either setting their type to GeneralAddOnObject or leaving them from <code>oldFormatAddOnObjectArray</code>. </dd></dl>

</div>
</div>
<a id="ga9fe6d5cd2f42b1f4b63d5f9a82f526d1" name="ga9fe6d5cd2f42b1f4b63d5f9a82f526d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fe6d5cd2f42b1f4b63d5f9a82f526d1">&#9670;&#160;</a></span>ACAPI_AddOnObject_ModifyObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_ModifyObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GS::UniString *</td>          <td class="paramname"><span class="paramname"><em>newObjectName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GSHandle *</td>          <td class="paramname"><span class="paramname"><em>newObjectContent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the content and/or the name of the specified AddOnObject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuid</td><td>[in] The GUID of the object. </td></tr>
    <tr><td class="paramname">newObjectName</td><td>[in] The new name of the specified object. If nullptr, the name of the object remains the original name. Must be nullptr if modifying a Unique AddOnObject. </td></tr>
    <tr><td class="paramname">newObjectContent</td><td>[in] The new content of the specified object. If nullptr, the content of the object remains the original content. Must not be nullptr if modifying a Unique AddOnObject. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - If the passed objectGuid parameter is NULLGuid, or if neither newObjectName nor newObjectContent is filled, or if modifying a Unique AddOnObject and either newObjectName is not nullptr (it must be) or newObjectContent is nullptr (it must not be).</li>
<li>APIERR_BADID - The specified object does not exist.</li>
<li>APIERR_NOTMINE - The object is not owned by the current user in teamwork mode. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used for modifying the content or the name of the specified AddOnObject. The newObjectContent handle will be copied inside the function so it has to be deleted after the function call. </dd></dl>

</div>
</div>
<a id="ga97e24e67ec25955d5e214e2b2f9b6c3a" name="ga97e24e67ec25955d5e214e2b2f9b6c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97e24e67ec25955d5e214e2b2f9b6c3a">&#9670;&#160;</a></span>ACAPI_AddOnObject_RegisterAddOnObjectHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_RegisterAddOnObjectHandler </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the add-on to be called for merging and converting its custom data stored in AddOnObjects. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function from RegisterInterface to let Archicad know that the add-on has APIAddOnObjectMergeHandlerProc and/or APIAddOnObjectSaveOldFormatHandlerProc and/or APIAddOnObjectConvertNewFormatHandlerProc callback function implemented for merging and converting its custom data. In order this functions to be called on the adequate event, the add-on needs to pass the function pointers to Archicad from Initialize with <a class="el" href="#ga6e4d7f8d3345a62a773624af71425334">ACAPI_AddOnObject_InstallAddOnObjectMergeHandler</a>, <a class="el" href="#gaf98ed8a5d6ea2eb54ab51d23af1bb097">ACAPI_AddOnObject_InstallAddOnObjectSaveOldFormatHandler</a> and <a class="el" href="#gae9aacf50e6bec4ec19f1f21929033493">ACAPI_AddOnObject_InstallAddOnObjectConvertNewFormatHandler</a>, respectively. </dd></dl>

</div>
</div>
<a id="ga685ae0a4af791e1240c5c317bb2b71ec" name="ga685ae0a4af791e1240c5c317bb2b71ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685ae0a4af791e1240c5c317bb2b71ec">&#9670;&#160;</a></span>ACAPI_AddOnObject_ReleaseObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_ReleaseObjects </td>
          <td>(</td>
          <td class="paramtype">const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuids</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In teamwork mode this function releases the specified objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuids</td><td>[in] The list of the objects which must be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuids is empty or contains APINULLGuid.</li>
<li>APIERR_BADID - If any of the objectGuids is not an AddOnObject GUID. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If any of the specified objects were modified, Send Changes operation will be performed in order to send the modified objects to server. </dd></dl>

</div>
</div>
<a id="gafec5a52f403966a9136859b9a3c8e19c" name="gafec5a52f403966a9136859b9a3c8e19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafec5a52f403966a9136859b9a3c8e19c">&#9670;&#160;</a></span>ACAPI_AddOnObject_RequestObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_RequestObjects </td>
          <td>(</td>
          <td class="paramtype">const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>mailText</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In teamwork mode this function sends a request mail in order to request the specified objects from the owners. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuids</td><td>[in] The list of the objects which must be requested. </td></tr>
    <tr><td class="paramname">mailText</td><td>[in] The text of the request mail. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuids is empty or contains APINULLGuid.</li>
<li>APIERR_BADID - If any of the objectGuids is not an AddOnObject GUID. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga04e07012bf57649cef42b82237ab2bc3" name="ga04e07012bf57649cef42b82237ab2bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e07012bf57649cef42b82237ab2bc3">&#9670;&#160;</a></span>ACAPI_AddOnObject_ReserveObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_ReserveObjects </td>
          <td>(</td>
          <td class="paramtype">const GS::Array&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>objectGuids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GS::HashTable&lt; <a class="el" href="struct_a_p_i___guid.html">API_Guid</a>, short &gt; *</td>          <td class="paramname"><span class="paramname"><em>conflicts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In teamwork mode this function reserves the specified objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuids</td><td>[in] The list of the objects which must be released. </td></tr>
    <tr><td class="paramname">conflicts</td><td>[out] Can be nullptr. If some of the specified objects cannot be reserved because of reservations of other users, this table will be filled with the conflicts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - The passed parameter objectGuids is empty or contains APINULLGuid.</li>
<li>APIERR_BADID - If any of the objectGuids is not an AddOnObject GUID. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If any of the specified objects were modified by another user, Receive Changes operation will be performed in order to get the latest version of the objects from the server. </dd></dl>

</div>
</div>
<a id="ga02caa4564303ee142721d174f130aa37" name="ga02caa4564303ee142721d174f130aa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02caa4564303ee142721d174f130aa37">&#9670;&#160;</a></span>ACAPI_AddOnObject_SetUIProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSErrCode ACAPI_AddOnObject_SetUIProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_i___guid.html">API_Guid</a> *</td>          <td class="paramname"><span class="paramname"><em>objectGuid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GS::UniString *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GS::UniString &amp;</td>          <td class="paramname"><span class="paramname"><em>localisedName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>dialogMenuStringId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets various UI properties of an AddOnObject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectGuid</td><td>[in] GUID of the specified object. Can be NULL if name-based identification is intended. </td></tr>
    <tr><td class="paramname">name</td><td>[in] The name of the specified object. Can be NULL if only GUID-based identification is intended. </td></tr>
    <tr><td class="paramname">localisedName</td><td>[in] The localised name of the specified object (or objects if objectGuid is NULL and there are more AddOnObjects with the same name). </td></tr>
    <tr><td class="paramname">dialogMenuStringId</td><td>[in] The id of the menu which must be called if Show button is pressed on Teamwork User interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>NoError - The function has completed with success.</li>
<li>APIERR_BADPARS - Both objectGuid and name are NULL, or localisedName is empty string. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used to register UI properties for AddOnObject. UI properties are localised name and the menu command id. The registered properties will be used for all AddOnObjects which have the specified GUID or name. If Archicad looks for a UI property, first tries to find it by GUID. If the property is not found, Archicad also tries to find it by name. So the registration can be done even if no instance of AddOnObject exists: in this case objectGuid should be NULL. Please note that if only the name is given for a UI property, then all AddOnObjects (both general and unique) with this name will have the same UI property. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</body>
</html>
